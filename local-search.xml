<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编译原理期末复习（4）</title>
    <link href="/2020/07/10/%E7%BC%96%E8%AF%914/"/>
    <url>/2020/07/10/%E7%BC%96%E8%AF%914/</url>
    
    <content type="html"><![CDATA[<p>编译原理4——运行存储分配</p><a id="more"></a><h1 id="第七章-运行存储分配"><a href="#第七章-运行存储分配" class="headerlink" title="第七章 运行存储分配"></a>第七章 运行存储分配</h1><h5 id="存储组织"><a href="#存储组织" class="headerlink" title="存储组织"></a>存储组织</h5><ul><li>编译器在工作过程中，必须为程序中出现的一些数据对象分配运行时的存储空间</li><li>对于那些编译时刻就可以确定大小的数据对象，可以在<strong>编译时刻</strong>就为之分配——静态存储分配</li><li>不能在编译时完全确定数据对象的大小——动态存储分配<ul><li>在编译时仅产生各种必要的信息，在<strong>运行时刻</strong>在动态分配存储空间<ul><li>栈式&amp;堆式</li></ul></li></ul></li><li>活动记录：<ul><li>使用过程（函数/方法）作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间</li><li>过程体每次执行称为该过程的一个<strong>活动</strong></li><li>过程每执行一次，就为它分配一块连续存储区，用来管理过程的一次执行所需的信息，这块连续存储区称为<strong>活动记录</strong></li></ul></li></ul><h5 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h5><ul><li>编译器为每个过程确定其活动记录在目标程序中的位置<ul><li>确定了每个名字存储位置</li></ul></li><li>这些名字的存储地址可以被编译到目标代码中</li><li><p>过程每次执行时，它的名字都绑定到同样的存储单元</p></li><li><p>适合语言条件</p><ul><li>数组上下界必须是常数</li><li>不允许递归的过程调用</li><li>不允许动态建立数据实体</li></ul></li><li>常用静态存储分配方法<ul><li>顺序分配法<ul><li>按照过程分配的先后顺序逐段分配存储空间</li><li>各过程的活动记录占用互不相交的存储空间</li><li>优点：处理简单</li><li>缺点：不够经济合理</li></ul></li><li>层次分配法<ul><li>通过对过程间的调用关系进行分析，凡属于无相互调用关系的并列过程，尽量使用其局部数据共享存储单元。</li><li>B[n][n]：过程调用关系矩阵<ul><li>B[i][j]：1——第i个过程调用第j个过程；0——不调用</li></ul></li><li>Units[n]：过程所需内存量矩阵</li><li>base[i]：第i个过程局部数据区的基地址</li><li>allocate[i]：第i个过程局部数据区是否分配的标志</li></ul></li></ul></li></ul><h5 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h5><ul><li><p>有些语言使用过程、函数或方法作为用户自定义动作的单元，几乎所有针对这些语言的编译器都把它们的运行时刻存储以栈的形式进行管理。</p></li><li><p>当一个过程被调用时，该过程的活动记录被压入栈；当过程结束时，该活动记录被弹出栈。</p></li><li><p>这种安排不仅允许活跃时段不交叠的的多个过程调用之间共享空间，而且允许以如下过程编译代码：</p><ul><li>非局部变量的相对地址总是固定的，和过程调用序列无关</li></ul></li><li><p><strong>活动树</strong></p><ul><li><p>用来描述程序运行期间控制进入和离开的各个活动的情况的树</p></li><li><p>在表示过程p的某个活动的结点上，其子结点对应于被p的这次活动调用的各个过程的活动。按照这些活动被调用的顺序，自左向右的显示它们。一个子结点必须在其右兄弟结点的活动开始之前结束。</p><ul><li>每个活跃的活动都有一个位于控制栈中的活动记录</li><li>活动树的根的活动记录位于栈底</li><li>程序控制所在的活动记录位于栈顶</li><li>栈中全部活动记录的序列对应于在活动树中到达当前控制所在的活动结点的路径。</li></ul></li><li><p>设计活动树的一些原则</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB7.assets/image-20200608151024865.png" srcset="/img/loading.gif" alt="image-20200608151024865" style="zoom:67%;"></p></li></ul></li><li><p>调用序列和返回序列</p><ul><li><p>过程调用和过程返回都需要执行一些代码来管理活动记录站，保存或恢复机器状态等</p><ul><li>调用序列：实现过程调用的代码段，为一个活动记录在栈中分配空间，并在此记录的字段中填写信息。</li><li>返回序列：恢复机器状态，使得调用过程能够在被调用结束后继续执行。</li><li>一个调用代码序列中的代码通常被分割到调用过程和被调用过程中；返回序列同理。</li></ul></li><li><p>调用序列</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB7.assets/image-20200608162300321.png" srcset="/img/loading.gif" alt="image-20200608162300321" style="zoom:67%;"></p></li><li><p>返回序列</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB7.assets/image-20200608162340189.png" srcset="/img/loading.gif" alt="image-20200608162340189" style="zoom:67%;"></p></li></ul></li><li><p>调用者和被调用者之间的任务划分</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB7.assets/image-20200608162434542.png" srcset="/img/loading.gif" alt="image-20200608162434542" style="zoom:67%;"></p></li><li><p>变长数据的存储分配</p><ul><li>在现代程序设计语言中，在编译时刻不能确定大小的对象被分配到<strong>堆</strong>区；但是过程的局部对象也可以分配在运行时刻栈中。<ul><li>尽量将对象放置在<strong>栈</strong>区原因：避免垃圾回收，减小开销</li></ul></li><li>只有一个数据对象局部于某个过程，且当此过程结束时它变得不可访问，才可以使用栈为这个对象分配空间。</li></ul></li></ul><ul><li><p><strong>非局部数据的访问</strong></p><ul><li>一个过程除了可以使用过程自身定义的局部数据以外，还可以使用过程外定义的非局部数据</li><li>语言可以分为两种类型<ul><li>支持过程嵌套声明的的语言<ul><li>可以在一个过程中声明另一个过程（eg：Pascal）</li></ul></li><li>不支持过程嵌套声明的语言<ul><li>eg：C</li></ul></li></ul></li></ul></li><li><p><strong>无过程嵌套声明时的数据访问</strong></p><ul><li>变量的存储分配和访问<ul><li>全局变量被分配在静态区使用静态确定的地址访问它们</li><li>其他变量一定是栈顶活动的局部变量，可以通过运行时栈的top_sp指针访问它们</li></ul></li></ul></li><li><p><strong>有过程嵌套声明时的数据访问</strong></p><ul><li>嵌套深度<ul><li>过程的嵌套深度<ul><li>不内嵌在任何其他过程中的过程，其嵌套深度为1</li><li>在嵌套深度为i的过程中定义的过程的嵌套深度为i+1</li></ul></li><li>变量的嵌套深度<ul><li>将变量声明所在过程的嵌套深度作为该变量得分嵌套深度</li></ul></li></ul></li></ul></li><li><p><strong>访问链</strong></p><ul><li>静态作用域规则：只要过程b的声明嵌套在a的声明中，过程b就可以访问过程a中声明的对象</li><li>在相互嵌套的过程活动记录之间建立访问链（指针），使得内嵌的过程可以访问外层过程中声明的对象<ul><li>如果b在源代码中直接嵌套于a（$n_b=n_a+1，n为嵌套深度$），那么b的任何活动中的访问链指针都指向最近的a的活动</li></ul></li></ul></li><li><p>访问链的建立</p><ul><li>建立访问链的代码属于调用序列的一部分</li><li>过程x调用过程y：<ul><li>$n_x&lt;n_y$：y一定由x直接定义，$n_y=n_x+1$<ul><li>在y的访问链中放置一个指向x的活动记录的指针</li></ul></li><li>$n_x=n_y$：本层调用本层（eg：递归）<ul><li>直接复制上层的访问链</li></ul></li><li>$n_x&gt;n_y$：调用者x嵌套于某过程z，而z中直接定义了被调用者y<ul><li>y的访问链指向z的距离栈顶最近的活动记录（$n_x-n_y+1$步）</li></ul></li></ul></li></ul></li></ul><h5 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h5><ul><li>符号表的组织<ul><li>为每个作用域（程序块）建立一个独立的符号表</li><li>这种为每个过程或作用域建立的符号表与编译时的活动记录是对应的。一个过程的非局部名字的信息可以通过扫描外围过程的符号表得到。</li></ul></li><li><p>标识符的基本处理方法</p><ul><li>当某一层的声明语句中识别出一个标识符（定义出现）时，以此标识符查询本层的符号表<ul><li>查到——id重复声明</li><li>没查到——进行登记，将相关信息填入符号表</li></ul></li><li>在可执行语句中发现标识符（应用出现）<ul><li>在该层符号表中查找，找不到则到直接外层找，逐步向外查找，一旦找到则取出相关信息并处理</li><li>所有外层都找不到——id未声明</li></ul></li></ul></li><li><p>符号表的建立</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理期末复习（3）</title>
    <link href="/2020/07/10/%E7%BC%96%E8%AF%913/"/>
    <url>/2020/07/10/%E7%BC%96%E8%AF%913/</url>
    
    <content type="html"><![CDATA[<p>编译原理3——语法制导翻译&amp;中间代码生成</p><a id="more"></a><h1 id="第五章-语法制导翻译"><a href="#第五章-语法制导翻译" class="headerlink" title="第五章 语法制导翻译"></a>第五章 语法制导翻译</h1><p>语法制导翻译：</p><ul><li>语法分析</li><li>语义分析</li><li>中间代码生成</li></ul><p>语义翻译：</p><ul><li>语义分析</li><li>中间代码生成</li></ul><h5 id="语法制导定义（SDD）"><a href="#语法制导定义（SDD）" class="headerlink" title="语法制导定义（SDD）"></a>语法制导定义（SDD）</h5><ul><li>将每个文法符号和一个语义属性集合相关联</li><li>将每个产生式和一组语义规则相关联，用于计算该产生式中各文法符号的属性值。</li></ul><h5 id="语法制导翻译方案（SDT）"><a href="#语法制导翻译方案（SDT）" class="headerlink" title="语法制导翻译方案（SDT）"></a>语法制导翻译方案（SDT）</h5><ul><li>在产生式右部嵌入了程序片段的CFG，这些程序片段被称为语义动作（语义动作放在花括号内）</li><li>一个语义动作在产生式中的位置决定了这个动作的执行时间</li></ul><h5 id="文法符号的属性"><a href="#文法符号的属性" class="headerlink" title="文法符号的属性"></a>文法符号的属性</h5><ul><li>综合属性<ul><li>只能通过子节点或本身的属性值定义</li><li>终结符可以具有综合属性（有词法分析器提供的词法值）</li></ul></li><li>继承属性<ul><li>只能通过父节点、兄弟节点或本身的属性值定义</li><li>终结符没有继承属性</li></ul></li><li>注释分析树：每个节点都带有属性值的分析树</li><li>副作用</li><li>属性文法：一个没有副作用的SDD又是也称为属性文法<ul><li>属性文法的规则仅仅通过其他属性值和常量来定义一个属性值</li></ul></li><li>依赖图：描述分析树种节点属性间依赖关系的有向图<ul><li>分析树中每个标号为x的节点的每个属性a都对应着依赖图中的一个节点</li><li>如果X.a的值依赖着 Y.b的值，则存在后者节点指向前者节点的有向边。</li></ul></li></ul><h5 id="两类SDD"><a href="#两类SDD" class="headerlink" title="两类SDD"></a>两类SDD</h5><ul><li>S属性定义（S-SDD）<ul><li>仅仅使用综合属性 </li><li>可按照任意一个自底向上的顺序计算属性值</li></ul></li><li>L属性定义（L-SDD）<ul><li>每个属性要么是综合属性，要么是满足如下条件的继承属性：<ul><li>假设存在一个产生式 $A \rightarrow X_1X_2X_3…X_{i-1}$，其右部符号的继承属性仅依赖于下列属性：</li><li>A的继承属性</li><li>产生式中该符号左边的属性</li><li>该符号本身的属性，但是其全部属性不能在依赖图中形成环路</li></ul></li></ul></li></ul><h5 id="SDT"><a href="#SDT" class="headerlink" title="SDT"></a>SDT</h5><ul><li><p>语法制导翻译方案是在产生式右部中嵌入了程序片段（被称为语义动作）的CFG。</p></li><li><p>可以看作是SDD的具体实施方案</p></li><li><p>两种SDT可在语法分析过程中实现的情况：</p><ul><li>LL分析+L属性SDD</li><li>LR分析+S属性SDD</li></ul></li><li><p>S-SDD转换为SDT的方法：每个语义动作放在产生式的最后</p><ul><li>SDT实现：在LR语法分析过程中当规约发生时执行相应的语义动作</li><li>在分析站中使用一个附加的域来存放综合属性值</li><li>将语义动作中的抽象定义式改写成具体可执行的栈操作</li></ul></li><li><p>L-SDD转化成SDT：</p><ul><li>将计算某个非终结符号A的继承属性的动作插入到产生式右部仅靠A本次出现之前的位置上</li><li>将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端</li></ul></li><li><p>L属性定义的SDT实现：</p><ul><li><p>在非递归的预测分析过程中进行语义翻译</p><ul><li>扩展语法分析栈</li><li>分析栈中的每一个记录都对应这一段执行代码</li><li>综合记录出栈时，要将综合属性值赋值给后面特定的语义动作</li><li>变量展开时，如果其含有继承属性，则要将继承属性值复制给后面特定的语义动作</li></ul></li><li><p>在递归的预测分析过程中进行语义翻译</p><ul><li>为每个非终结符A构造一个函数，A的每个继承属性对应该函数的一个形参，函数的返回值是A的的综合属性值。</li><li>对出现在A产生式中的每个文法符号的每个属性都设置一个局部变量</li><li>非终结符A的代码根据当前的输入决定使用哪个产生式</li><li>与每个产生式有关的代码，从左到右考虑产生式右部的词法单元、非终结符及语义动作<ul><li>对于带有综合属性x的词法单元X，把x的值保存在局部变量X.x中额案后产生一个匹配X的调用，并继续输入</li><li>对于非终结符B，产生又不带有函数调用的赋值语句</li><li>对于每个语义动作，直接转移到语法分析器中</li></ul></li></ul></li><li><p>在LR分析的过程中进行语义翻译（自底向上）</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB5.assets/image-20200529165841027.png" srcset="/img/loading.gif" alt="image-20200529165841027" style="zoom: 67%;"></p></li></ul></li></ul><h2 id="第六章-中间代码生成"><a href="#第六章-中间代码生成" class="headerlink" title="第六章 中间代码生成"></a>第六章 中间代码生成</h2><h5 id="声明语句的翻译"><a href="#声明语句的翻译" class="headerlink" title="声明语句的翻译"></a>声明语句的翻译</h5><ul><li>主要任务：收集标识符的类型等属性信息，并为每一个名字分配一个相对地址</li><li>类型表达式<ul><li>基本类型（integer、real、char、boolean、type_error、void）</li><li>为类型表达式命名，类型名也是类型表达式</li><li>将类型构造符作用域类型表达式可以构成新的类型表达式<ul><li>eg：array（数组构造符）、pointer（指针构造符）、$\times$（笛卡尔积构造符）、$\rightarrow$（函数构造符）、record（记录构造符）</li></ul></li></ul></li><li>局部变量的存储分配<ul><li>从类型表达式可知该类型在运行时所需的存储单元数量——类型的宽度</li><li>在编译时刻，可以使用类型的宽度为每个名字分配一个相对地址</li><li>名字的类型和相对地址信息保存在相应的符号表里</li></ul></li></ul><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200529211430291.png" srcset="/img/loading.gif" alt="image-20200529211430291" style="zoom: 67%;"></p><h5 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h5><ul><li><p>简单赋值语句的翻译</p><ul><li>主要任务：生成对表达式求值的三地址码</li></ul><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200529213554528.png" srcset="/img/loading.gif" alt="image-20200529213554528" style="zoom: 67%;"></p><ul><li>增量翻译<ul><li>在增量方法中，gen()指令不仅要构造新的三地址指令，还要将其添加到迄今为止已经生成的指令序列之后</li></ul></li></ul></li><li><p>数组引用的翻译</p><ul><li><p>主要问题：却低估数组元素的存放地址（数组元素的寻址）</p></li><li><p>数组元素寻址：</p><ul><li><p>一维数组：每个数组元素的宽度时w，则a[i]的相对地址是 $base + iw$</p></li><li><p>k维数组：$base + i_1w_1+ i_2w_2+ … +i_kw_k$ </p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605150750828.png" srcset="/img/loading.gif" alt="image-20200605150750828" style="zoom:50%;"></p></li></ul></li></ul></li></ul><h5 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h5><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605152117330.png" srcset="/img/loading.gif" alt="image-20200605152117330" style="zoom:67%;"></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605152434442.png" srcset="/img/loading.gif" alt="image-20200605152434442" style="zoom: 67%;"></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605152450706.png" srcset="/img/loading.gif" alt="image-20200605152450706" style="zoom:67%;"></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605152525036.png" srcset="/img/loading.gif" alt="image-20200605152525036" style="zoom:67%;"></p><p><strong>布尔表达式的翻译</strong></p><ul><li>在跳转代码中，逻辑运算符&amp;&amp;，||和！被翻译成跳转指令，运算符本身不出现在代码中。布尔表达式的值是通过代码序列中的位置来表示的。</li></ul><h5 id="回填"><a href="#回填" class="headerlink" title="回填"></a>回填</h5><ul><li><p>基本思想</p><ul><li>生成一个跳转指令时，暂时不指定该跳转指令的目标标号。这样的指令都放入由跳转指令组成的列表中。同一个列表的所有跳转指令具有相同的目标标号，确定时进行填充。</li></ul></li><li><p>非终结符的综合属性</p><ul><li>B.truelist<ul><li>指向一个包含跳转指令的列表，这些指令最终获得的目标标号就是B为真时应该转向的标号</li></ul></li><li>B.falselist</li></ul></li><li><p>函数</p><ul><li><p>$makelist(i)$</p><ul><li>创建一个只包含 i 的列表，i 是跳转指令的标号，函数返回指向新创建列表的指针。</li></ul></li><li><p>$merge(p_i,p_2)$</p><ul><li>将两者指向的列表进行合并，返回合并后列表的指针</li></ul></li><li><p>$backpatch(p,i)$</p><ul><li>将i作为目标标号插入到p指向列表的所有指令中</li></ul></li></ul></li></ul><h5 id="switch语句的翻译"><a href="#switch语句的翻译" class="headerlink" title="switch语句的翻译"></a>switch语句的翻译</h5><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605160003367.png" srcset="/img/loading.gif" alt="image-20200605160003367" style="zoom:67%;"></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605160032474.png" srcset="/img/loading.gif" alt="image-20200605160032474" style="zoom: 67%;"></p><h5 id="过程调用语句的翻译"><a href="#过程调用语句的翻译" class="headerlink" title="过程调用语句的翻译"></a>过程调用语句的翻译</h5><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB6.assets/image-20200605155723904.png" srcset="/img/loading.gif" alt="image-20200605155723904" style="zoom:67%;"></p><h5 id="语义分析中的错误检测"><a href="#语义分析中的错误检测" class="headerlink" title="语义分析中的错误检测"></a>语义分析中的错误检测</h5><ul><li>变量或者过程未声明就使用</li><li>变量或过程名重复声明</li><li>运算分量类型不匹配 </li><li>操作符与操作数之间的类型不匹配<ul><li>数组下标不是整数</li><li>非数组变量使用数组访问操作符</li><li>非过程名使用过程调用操作符</li><li>过程调用的参数类型或者数目不匹配</li><li>函数返回类型有误</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理期末复习（2）</title>
    <link href="/2020/07/10/%E7%BC%96%E8%AF%912/"/>
    <url>/2020/07/10/%E7%BC%96%E8%AF%912/</url>
    
    <content type="html"><![CDATA[<p>编译原理2——词法分析&amp;语法分析</p><a id="more"></a><h1 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h1><h5 id="单词的描述"><a href="#单词的描述" class="headerlink" title="单词的描述"></a>单词的描述</h5><ul><li>正则表达式（RE）<ul><li>可以由较小的正则表达式按照规则递归地构建，每个正则表达式定义一个语言。</li></ul></li><li>正则语言：可以用RE定义的语言叫做<strong>正则语言</strong>或<strong>正则集合</strong></li><li>正则文法与正则表达式等价</li></ul><h5 id="单词的识别"><a href="#单词的识别" class="headerlink" title="单词的识别"></a>单词的识别</h5><ul><li><p>有穷自动机（FA）</p><ul><li>离散的输入输出信息&amp;又穷数目的内部状态</li><li>系统只需根据当前所处的状态和当前面临的输入信息就可以决定系统的后继行为</li></ul></li><li><p>FA模型：输入带、读头、有穷控制器</p></li><li>FA的表示：转换图</li><li>FA定义（接收）的语言</li><li><p>最长字串匹配原则</p></li><li><p>FA的分类：</p><ul><li>确定的FA（DFA）<ul><li>$M = (S, \sum, \delta,s_0,F)$<ul><li>S：有穷状态集</li><li>$\sum$：输入字母表（不包括$\varepsilon$）</li><li>$\delta$：转换函数：将$S \times \sum$ 映射到$S$</li><li>$s_0$：开始状态</li><li>$F$：接收（终止）状态集合</li></ul></li></ul></li><li>非确定的FA（NFA）<ul><li>$M = (S, \sum, \delta,s_0,F)$</li><li>$\delta$：转换函数：将$S \times \sum$ 映射到 $2S$</li></ul></li><li>带有”$\varepsilon-$边”的NFA<ul><li>$\delta$：转换函数：将$S \times （\sum \cup\{\varepsilon\}$ 映射到$2S$</li></ul></li></ul></li><li>子集构造法：从NFA构造等价DFA</li></ul><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB3.assets/image-20200525221557719.png" srcset="/img/loading.gif" alt="image-20200525221557719" style="zoom: 50%;"></p><h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><ul><li>错误类型：<ul><li>单词拼写错误</li><li>非法字符</li></ul></li><li>错误检测：对应信息为空且不是终止，进入错误处理</li><li><p>错误处理：查找最近的终态对应字符</p><ul><li>找到将前面识别为一个单词，并从该字符后重新识别</li><li>找不到则进行错误恢复</li></ul></li><li><p>错误恢复：恐慌模式</p></li></ul><h5 id="词法分析器生成工具Lex"><a href="#词法分析器生成工具Lex" class="headerlink" title="词法分析器生成工具Lex"></a>词法分析器生成工具Lex</h5><h1 id="第四章-语法分析"><a href="#第四章-语法分析" class="headerlink" title="第四章 语法分析"></a>第四章 语法分析</h1><h3 id="语法分析-上"><a href="#语法分析-上" class="headerlink" title="语法分析 上"></a>语法分析 上</h3><h6 id="主要任务：根据给定文法识别输入句子各个成分以构造分析树"><a href="#主要任务：根据给定文法识别输入句子各个成分以构造分析树" class="headerlink" title="主要任务：根据给定文法识别输入句子各个成分以构造分析树"></a>主要任务：根据给定文法识别输入句子各个成分以构造分析树</h6><h6 id="大部分程序设计语言的语法构造可以用CFG来描述，CFG以token作为终结符"><a href="#大部分程序设计语言的语法构造可以用CFG来描述，CFG以token作为终结符" class="headerlink" title="大部分程序设计语言的语法构造可以用CFG来描述，CFG以token作为终结符"></a>大部分程序设计语言的语法构造可以用CFG来描述，CFG以token作为终结符</h6><h5 id="语法分析的种类"><a href="#语法分析的种类" class="headerlink" title="语法分析的种类"></a>语法分析的种类</h5><ul><li>自顶向下的分析——推导</li><li>自底向上的分析——归约</li></ul><h5 id="自顶向下的分析"><a href="#自顶向下的分析" class="headerlink" title="自顶向下的分析"></a>自顶向下的分析</h5><h6 id="替换哪个非终结符？用哪个候选式替换？"><a href="#替换哪个非终结符？用哪个候选式替换？" class="headerlink" title="替换哪个非终结符？用哪个候选式替换？"></a>替换哪个非终结符？用哪个候选式替换？</h6><ul><li>最左推导：总是选择每个句型的最左非终结符进行替换<ul><li>对应最右归约</li></ul></li><li>最右推导：总是选择每个举行的最右非终结符进行替换<ul><li>对应最左归约</li></ul></li></ul><h6 id="自底向上的分析中总是采用最左归约，因此最左归约成为规范归约，而最右推导则相应称为规范推导"><a href="#自底向上的分析中总是采用最左归约，因此最左归约成为规范归约，而最右推导则相应称为规范推导" class="headerlink" title="自底向上的分析中总是采用最左归约，因此最左归约成为规范归约，而最右推导则相应称为规范推导"></a>自底向上的分析中总是采用最左归约，因此最左归约成为规范归约，而最右推导则相应称为规范推导</h6><h6 id="自顶向下的语法采用最左推导"><a href="#自顶向下的语法采用最左推导" class="headerlink" title="自顶向下的语法采用最左推导"></a>自顶向下的语法采用最左推导</h6><ul><li><p><strong>递归下降分析</strong>（可能需要回溯，效率较低）</p><ul><li><p>同一非终结符的多个候选式存在共同前缀，将导致回溯现象</p></li><li><p>左递归文法会陷入无限循环</p><ul><li><p>直接左递归和间接左递归</p></li><li><p>消除直接左递归——代价：引进了一些非终结符和空产生式</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200526145955148.png" srcset="/img/loading.gif" alt="image-20200526145955148" style="zoom:50%;"></p></li></ul></li><li><p>提取左公因子——意义：推迟决定，做出更正确的选择</p></li></ul></li><li><p><strong>预测分析</strong>（不需要回溯、确定的自顶向下分析方法）</p></li></ul><h5 id="预测分析法"><a href="#预测分析法" class="headerlink" title="预测分析法"></a>预测分析法</h5><ul><li><p>S_文法：简单的确定性文法（不包含空产生式）</p><ul><li>右部终结符开始且部首终结符不同</li></ul></li><li><p>Follow集（后继符号集）：对于非终结符A，可能在某个句型种紧跟在A后面的终结符的集合</p><ul><li>若A为某个句型的最右符号，则将 ‘$’ 加入</li></ul></li><li><p>Select集（可选集）：可以选用该产生式进行推导时对应的输入符号的集合</p></li><li><p>q_文法</p><ul><li>每个产生式右部以终结符开始或为空，左部相同的产生式select集不相交</li></ul></li><li><p>First集（串首终结符集）：可从给定文法符号串推导出的所有串首终结符构成的集合</p></li><li><p>Select集计算：</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200526152535043.png" srcset="/img/loading.gif" alt="image-20200526152535043" style="zoom:50%;"></p></li><li><p><strong>LL（1）文法</strong></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200526152810979.png" srcset="/img/loading.gif" alt="image-20200526152810979" style="zoom:50%;"></p></li></ul><p>  <img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200526152939306.png" srcset="/img/loading.gif" alt="image-20200526152939306" style="zoom: 50%;"></p><ul><li><p>LL(1)文法的分析方法：</p><ul><li><p>递归的预测分析法：为每个非终结符编写对应的过程</p></li><li><p>非递归的预测分析法（表驱动的预测分析）：构造自动机</p></li><li><p>预测分析法的实现步骤：构造文法、改造文法、求三个集、构造分析表、实现分析过程</p></li><li><p>错误检测：</p><ul><li>栈顶终结符与输入不匹配</li><li>预测结果为空</li></ul></li><li><p>错误恢复：恐慌模式+同步词法单元</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200526153604303.png" srcset="/img/loading.gif" alt="image-20200526153604303" style="zoom:50%;"></p></li></ul></li></ul><h3 id="语法分析-中"><a href="#语法分析-中" class="headerlink" title="语法分析 中"></a>语法分析 中</h3><h5 id="自底向上的语法分析"><a href="#自底向上的语法分析" class="headerlink" title="自底向上的语法分析"></a>自底向上的语法分析</h5><h6 id="最左归约（反向构造最右推导）"><a href="#最左归约（反向构造最右推导）" class="headerlink" title="最左归约（反向构造最右推导）"></a>最左归约（反向构造最右推导）</h6><ul><li>通用框架：移入-归约分析<ul><li>对输入串从左到右扫描，将零个或多个输入符号移到栈的顶端，直到可以发生规约，则归约。</li><li>循环直到检测到错误或栈中包含开始符号且输入缓冲区为空</li></ul></li><li>句柄——句型的最左直接短语</li><li>移入-归约的四种动作：移入、归约、接收、报错</li></ul><h5 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h5><p>三种状态——移进状态、待约状态、规约状态</p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529145332435.png" srcset="/img/loading.gif" alt="image-20200529145332435" style="zoom:50%;"></p><h5 id="LR分析器总体结构"><a href="#LR分析器总体结构" class="headerlink" title="LR分析器总体结构"></a>LR分析器总体结构</h5><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529145420303.png" srcset="/img/loading.gif" alt="image-20200529145420303" style="zoom:67%;"></p><h5 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h5><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529145911333.png" srcset="/img/loading.gif" alt="image-20200529145911333" style="zoom:67%;"></p><h5 id="LR（0）分析"><a href="#LR（0）分析" class="headerlink" title="LR（0）分析"></a>LR（0）分析</h5><ul><li>右部某位置标有圆点的产生式称为相应文法的一个LR（0）项目<ul><li>项目描述了句柄识别的状态</li><li>空产生式只有一个项目$A\rightarrow ·$</li></ul></li><li>增广文法：如果G是一个以S为开始符号的文法，则G的增广文法G‘就是增加新开始符号S’，并增加$S’\rightarrow S$<ul><li>目的：使文法开始符号仅出现在一个产生式的左边，使分析器只有一个接受状态。</li></ul></li><li>后继项目：同一个产生式的项目，圆点位置只差一个符号</li><li>项目集闭包：等价的项目组成<ul><li>每个项目集闭包对应自动机的一个状态</li></ul></li><li><strong>CLOSURE函数</strong></li><li><strong>GOTO函数</strong></li><li>冲突：移入/归约冲突和归约/归约冲突<ul><li>LR（0）文法不能解决所有文法（CFG不是LR（0）文法）</li></ul></li></ul><h3 id="语法分析-下"><a href="#语法分析-下" class="headerlink" title="语法分析 下"></a>语法分析 下</h3><h5 id="SLR分析"><a href="#SLR分析" class="headerlink" title="SLR分析"></a>SLR分析</h5><p><img src="/img/%E7%BC%96%E8%AF%912.assets/image-20200529154308453.png" srcset="/img/loading.gif" alt="image-20200529154308453" style="zoom: 50%;"></p><p><img src="/img/%E7%BC%96%E8%AF%912.assets/image-20200529154847266.png" srcset="/img/loading.gif" alt="image-20200529154847266"></p><ul><li>移入/归约冲突：移入项目的移入符号在规约项目规约后的follow集中</li></ul><h5 id="LR（1）分析"><a href="#LR（1）分析" class="headerlink" title="LR（1）分析"></a>LR（1）分析</h5><ul><li><p>对于某个产生式的归约，在不同的使用位置要求不同的后继符号</p><ul><li>在特定位置，A的后继符号集合使FOLLOW（A）的子集</li></ul></li><li><p>展望符</p><ul><li>继承的后继符和自生的后继符</li></ul></li><li>如果除展望符外，两个LR（1）项目集相同，则称这两个是同心的</li></ul><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529161351439.png" srcset="/img/loading.gif" alt="image-20200529161351439" style="zoom:67%;"></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529161400598.png" srcset="/img/loading.gif" alt="image-20200529161400598" style="zoom:67%;"></p><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529161513326.png" srcset="/img/loading.gif" alt="image-20200529161513326" style="zoom:67%;"></p><h5 id="LALR分析"><a href="#LALR分析" class="headerlink" title="LALR分析"></a>LALR分析</h5><p><img src="/img/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529161558115.png" srcset="/img/loading.gif" alt="image-20200529161558115" style="zoom:67%;"></p><h5 id="二义性文法的LR分析"><a href="#二义性文法的LR分析" class="headerlink" title="二义性文法的LR分析"></a>二义性文法的LR分析</h5><ul><li>二义性文法都不是LR的<ul><li>使用优先级和结合性解决</li></ul></li><li>应该保守使用二义性文法，且有严格控制</li></ul><h5 id="LR分析中的错误处理"><a href="#LR分析中的错误处理" class="headerlink" title="LR分析中的错误处理"></a>LR分析中的错误处理</h5><ul><li><p>错误检测——分析表中的报错条目</p></li><li><p>错误恢复：</p><ul><li><p>恐慌模式</p><p><img src="/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB4.assets/image-20200529161955113.png" srcset="/img/loading.gif" alt="image-20200529161955113" style="zoom:50%;"></p></li><li><p>短语层次</p><ul><li>检查每一个报错条目后手动判断可能的错误因素并构造恢复过程</li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>编译原理期末复习（1）</title>
    <link href="/2020/07/10/%E7%BC%96%E8%AF%911/"/>
    <url>/2020/07/10/%E7%BC%96%E8%AF%911/</url>
    
    <content type="html"><![CDATA[<p>编译原理1——绪论&amp;语言及其文法</p><a id="more"></a><h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h5 id="语言及特点"><a href="#语言及特点" class="headerlink" title="语言及特点"></a>语言及特点</h5><ul><li>高级语言：类似于数学定义或自然语言的简洁形式<ul><li>接近人类表达习惯</li><li>不依赖于特定机器</li><li>编写效率高</li></ul></li><li>汇编语言：引入助记符<ul><li>依赖于特定机器，非计算机专业人员使用受限制</li><li>编写效率比较低</li></ul></li><li>机器语言：可以直接被计算机所理解<ul><li>难以记忆、编写、阅读</li><li>容易写错</li></ul></li></ul><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>​        将高级语言（源语言）翻译成汇编语言或者机器语言（目标语言）的过程。</p><h5 id="编译器所处位置"><a href="#编译器所处位置" class="headerlink" title="编译器所处位置"></a>编译器所处位置</h5><p>​        源程序$\rightarrow$[预处理器]$\rightarrow$经过预处理的源程序$\rightarrow$[编译器]$\rightarrow$汇编语言程序$\rightarrow$[汇编器]$\rightarrow$可重定位的机器代码$\rightarrow$[链接器/加载器]$\rightarrow$目标机器代码</p><h5 id="编译器的结构"><a href="#编译器的结构" class="headerlink" title="编译器的结构"></a>编译器的结构</h5><ul><li><p>分析部分/前端（与源语言相关）</p><ul><li>词法分析器：从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。<ul><li>将识别出的单词转换成统一的机内表示——词法单元（token）格式。\&lt;种别码，属性值&gt;</li></ul></li><li><p>语法分析器：从词法分析器输出的token序列中识别出各类短语，并构造语法分析树。</p></li><li><p>语义分析器：</p><ul><li>收集标识符的属性信息（种属、类型、存储位置、长度、值、作用域、参数和返回值信息）<ul><li>符号表：用于存放标识符的属性信息的数据结构</li></ul></li><li>语义检查<ul><li>变量或过程未声明就使用</li><li>变量或过程名重复声明</li><li>运算分量类型不匹配</li><li>操作符与操作数之间的类型不匹配<ul><li>数组下标不是整数</li><li>对非数组变量使用数组访问操作符</li><li>对非过程名使用过程调用操作符</li><li>过程调用的参数类型或数目不匹配</li><li>函数返回值类型有误</li></ul></li></ul></li></ul></li><li>中间代码生成器<ul><li>三地址码：由类似于汇编语言的指令序列，每个指令最多有三个操作数。</li><li>语法结构树/语法树</li></ul></li></ul></li><li><p>机器无关代码优化器</p></li><li><p>综合部分/后端（与目标语言相关）</p><ul><li>目标代码生成器：以源程序的中间表示形式作为输入，把它映射到目标语言。<ul><li>为程序中使用的变量合理分配寄存器。</li></ul></li><li>机器相关代码优化器</li></ul></li></ul><h6 id="代码优化：等价程序变换、运行更快、占用空间更少"><a href="#代码优化：等价程序变换、运行更快、占用空间更少" class="headerlink" title="代码优化：等价程序变换、运行更快、占用空间更少"></a>代码优化：等价程序变换、运行更快、占用空间更少</h6><h1 id="第二章-语言及其文法"><a href="#第二章-语言及其文法" class="headerlink" title="第二章 语言及其文法"></a>第二章 语言及其文法</h1><h5 id="串"><a href="#串" class="headerlink" title="串"></a>串</h5><ul><li>有穷符号序列</li><li>连接运算、幂运算</li></ul><h5 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h5><ul><li>有穷符号集合</li><li>乘积运算、幂运算、正闭包、克林闭包</li></ul><h5 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h5><ul><li>$G=(VT,VN,P,S)$<ul><li>VT:终结符集合；VN：非终结符集合；P：产生式集合；S：文法开始符号</li></ul></li><li>产生式简写：相同左部，右部竖线隔开，一个部分为一个候选式</li><li>约定：<ul><li>终结符：排在前面的小写字母、运算符、标点符号、粗体字符串</li><li>非终结符：排在前面的大写字母、S、小写或斜体的名字、代表程序构造的大写字母（E：表达式、T：项、F：因子）</li><li>字母表中排在后面的大写字母表示文法符号</li><li>字母表中排在后面的小写字母表示终结符号串</li><li>小写希腊字母表示文法符号串</li><li>第一个产生式左部为开始符号</li></ul></li></ul><h5 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h5><ul><li><p>推导和归约</p><ul><li><p>直接推导：用产生式发右部替换左部</p></li><li><p>n步推导</p></li><li><p>归约：自下而上——识别语言角度</p><p>推导：自上而下——生成语言角度</p></li></ul></li><li><p>句型和句子</p><ul><li>句型：既可以包含终结符，也可以包含非终结符、可以是空串</li><li>句子：不包含非终结符的句型</li></ul></li><li><p>语言的形式化定义：由文法G的开始符号S推导出的所有句子构成的集合成为文法G生成的语言，记为$L(G)$</p></li></ul><h5 id="文法的分类（Chomshy文法分类体系）"><a href="#文法的分类（Chomshy文法分类体系）" class="headerlink" title="文法的分类（Chomshy文法分类体系）"></a>文法的分类（Chomshy文法分类体系）</h5><ul><li>0型文法：无限制文法（UG）/短语结构文法（PSG）<ul><li>$\forall\alpha\rightarrow\beta\in P,\alpha$中至少包含一个非终结符。</li></ul></li><li>1型文法：上下文有关文法（CSG）<ul><li>$\forall\alpha\rightarrow\beta\in P,|\alpha|\leq|\beta|$</li><li>不包含空产生式</li></ul></li><li>2型文法：上下文无关文法（CFG）<ul><li>$\forall\alpha\rightarrow\beta\in P,\alpha\in VN$</li></ul></li><li><p>3型文法：正则文法（RG）</p><ul><li>右线性文法：$A\rightarrow wB$ 或 $A\rightarrow w$</li><li>左线性文法：$A\rightarrow Bw$ 或 $A\rightarrow w$</li></ul></li><li><p>四种文法逐级限制、逐级包含。</p></li></ul><h5 id="CFG的的分析树"><a href="#CFG的的分析树" class="headerlink" title="CFG的的分析树"></a>CFG的的分析树</h5><ul><li>根结点、内部结点、叶结点</li><li>树的产出或边缘：从左到右排列叶结点得到的符号串</li><li>分析树是推导的图形化表示</li><li>句型的短语：给定一个句型，其分析树中的每一颗子树的边缘称为该句型的一个短语。<ul><li>如果子树只有父子两代的结点，则这颗子树的边缘称为该句型的一个直接短语</li><li>直接短语一定是某产生式的右部，但是产生式的右部不一定是给定句型的直接短语。</li></ul></li><li>二义性文法<ul><li>如果一个文法可以为某个句子生成多颗分析树</li><li>消歧规则</li><li>二义性文法的判定：对于任意一个上下文无关文法，不存在一个算法判断它是无二义性的，但是可以给出是无二义性的充分条件</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统7</title>
    <link href="/2020/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7/"/>
    <url>/2020/07/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统7——并发控制&amp;数据库恢复。</p><a id="more"></a><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h5 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h5><ul><li>事务：用户定义的一个数据库操作序列，这些操作耀目全做，要么全不做，是一个不可分割的工作单位。</li><li>事务与程序不同<ul><li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li><li>一个程序通常包含多个事务</li></ul></li><li><p>事务是并发控制和恢复的基本单位</p></li><li><p>事务的特性（ACID）</p><ul><li>原子性（Atomicity）：完全执行或者完全不执行</li><li>一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态<ul><li>一致性状态：数据库中只包含成功事务提交的结果</li><li>不一致性状态：发生故障，有些事务被迫终端，而一部分修改已经写入物理数据库，此时数据库处于一种不正确的状态</li></ul></li><li>隔离性（Isolation）：表面看起来，每个事务都是在没有其他事务同时执行的情况下执行的<ul><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能相互干扰</li></ul></li><li>持久性（Durability）：一个事务一旦提交，它对数据库中数据的改变就应该是永久性的<ul><li>接下来执行的其他操作或故障不应该对其执行结果有任何影响</li></ul></li></ul></li><li>保证事务ACID特性是事务处理的任务</li><li><p>破坏ACID特性的因素：</p><ul><li>多个事务并行运行时，不同事务的操作交叉执行</li><li>事务在运行过程中被强行停止</li></ul></li><li><p>事务运用以下两个操作访问数据：</p><ul><li>Read(X)：从数据库把数据项X传送到事务的局部缓冲区</li><li>Write(X)：从事务的局部缓冲区把数据项传回数据库</li></ul></li></ul><h5 id="事务的并发执行和调度"><a href="#事务的并发执行和调度" class="headerlink" title="事务的并发执行和调度"></a>事务的并发执行和调度</h5><p>调度：一个或多个事务的重要操作按时间排序的一个序列</p><ul><li>串行调度</li></ul><p>可串行化调度：不管数据库初始状态如何，一个调度对数据库状态的影响都和某个串行调度相同，则称这个调度时可串行化的</p><p>冲突：调度中一对连续的动作，满足，如果二者顺序调换，那么涉及的事务中至少有一个的行伪会改变</p><ul><li>同一事务的两个动作冲突</li><li>不同事务对同一数据库元素的写冲突</li><li>不同事务对同一数据库元素的读和写冲突</li></ul><p>冲突可串行化：</p><ul><li>我们说两个调度是<strong>冲突等价</strong>的，如果通过一系列相邻动作的非冲突交换能将它们中的一个转换为另一个</li><li>如果说一个调度冲突等价于一个串行调度，那么我们说该调度是<strong>冲突可串行化</strong>的</li></ul><p>优先关系：</p><ul><li>已知调度S，其中涉及事务T1和T2，可能还有其他事务。我们说T1优先于T2，记作T1&lt;T2，如果有T1的动作A1和T2的动作A2，满足：<ul><li>在S中A1在A2前；</li><li>A1和A2都涉及同一组数据库元素，且，A1和A2中至少有一个动作是写</li></ul></li><li>因此，在任何冲突等价于S的调度中，A1将出现在A2前。所以，如果这些调度中有一个是串行调度，那么该调度必然使T1在T2前。</li></ul><p>优先图</p><ul><li>Ti &lt; Tj，有i到j的边</li></ul><p>冲突可串行性判断</p><ul><li>构造优先图，判断其中是否有环</li></ul><h5 id="并发控制协议"><a href="#并发控制协议" class="headerlink" title="并发控制协议"></a>并发控制协议</h5><p>包括：基于锁的协议、基于时间戳的协议、多版本机制、快照隔离</p><p><strong>基于锁的并发控制协议</strong></p><ul><li><p>锁的概念</p><h6 id="一个保证可串行性的方法使在互斥的方式下存取数据项，即，当一个事务存取一个数据项时，不允许其他事务修改这个数据项。（可以通过基于锁的并发控制协议实现）"><a href="#一个保证可串行性的方法使在互斥的方式下存取数据项，即，当一个事务存取一个数据项时，不允许其他事务修改这个数据项。（可以通过基于锁的并发控制协议实现）" class="headerlink" title="一个保证可串行性的方法使在互斥的方式下存取数据项，即，当一个事务存取一个数据项时，不允许其他事务修改这个数据项。（可以通过基于锁的并发控制协议实现）"></a>一个保证可串行性的方法使在互斥的方式下存取数据项，即，当一个事务存取一个数据项时，不允许其他事务修改这个数据项。（可以通过基于锁的并发控制协议实现）</h6><ul><li><p>锁的两种类型：</p><ul><li>共享锁：获取后可读不可写</li><li>互斥锁：获取后可读也可写</li></ul></li><li><p>每个事务在存取一个数据项之前必须获得这个数据项上的锁</p></li><li><p>一个事务需要获得的锁的类型依赖于它将在数据项上执行什么样的操作</p></li><li><p>相容关系：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7.assets/image-20200706202210951.png" srcset="/img/loading.gif" alt="image-20200706202210951" style="zoom: 67%;"></p></li></ul></li></ul><ul><li><p>事务通过执行<strong>LOCK-S(Q)</strong>操作申请数据项Q上的共享锁</p></li><li><p>事务通过执行<strong>LOCK-X(Q)</strong>操作申请数据项Q上的互斥锁</p></li><li><p><strong>UNLOCK(Q)</strong>操作用来释放数据项Q上的锁</p></li><li><p>一个事务完成了对一个数据项的最后一次存取后立刻放弃锁，可能无法确保调度的可串行性</p><ul><li>释放操作放到最后——可能死锁</li><li>死锁时必须放弃至少一个处于死锁状态的事务以使其他事务可以继续运行</li></ul></li></ul><ul><li><p>死锁、死锁的处理</p><ul><li>死锁预防：<ul><li>产生原因：两个或多个事务都已封锁了一些数据对象，然后又都请求对已经被其他食物封锁的数据对象加锁，从而出现死等待</li><li>因此要破坏产生死锁的条件</li><li>两个预防方法：<ul><li>一次封锁法<ul><li>要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li><li>问题：降低系统并发、难于实现精确确定封锁对象</li></ul></li><li>顺序封锁法<ul><li>预先对数据对象规定一个封锁顺序，所有事务都按照这个顺序进行封锁</li><li>问题：维护成本高、难以实现</li></ul></li></ul></li></ul></li><li>死锁的检测与恢复<ul><li>死锁的诊断：<ul><li>超时法：等待时间超过规定<ul><li>优点：实现简单</li><li>缺点：可能误判或不及时发现</li></ul></li><li>事务等待图法：用等待图动态反应所有事务的等待情况<ul><li>有向图G=(T,U)</li><li>T为节点集合，每个节点表示正运行的事务</li><li>U为边的集合，每条边表示事务等待的情况</li><li>若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2。</li><li>并发控制子系统周期性地生成等待图，如果发现图中存在回路，则表示出现了死锁</li></ul></li></ul></li><li>死锁的恢复<ul><li>选择牺牲者：必须决定回滚哪一个（哪一些）事务以打破死锁，使事务回滚代价最小</li><li>回滚：彻底回滚、部分回滚</li><li>饿死：总是同一事物被选为牺牲者<ul><li>需保证一个事务被选为牺牲者的次数有限</li></ul></li></ul></li></ul></li></ul></li><li><p>两段锁并发控制协议</p><ul><li>两段锁协议：要求每个事务分两个进行数据项加锁和解锁<ul><li>加锁阶段：事务申请可以获得任何数据项上的任何类型的锁，但是不能释放任何锁</li><li>解锁阶段：事务申请可以释放任何数据项上的任何类型的锁，但是不能申请任何锁</li></ul></li><li>每个事务开始运行后即进入加锁阶段，申请获得所需要是所有锁</li><li>当一个事务第一次释放锁时，该事务进入解锁阶段。进入解锁阶段的事务不能再申请任何锁</li></ul></li><li>两段锁改进：<ul><li>用UPGRADE表示共享锁到互斥锁转换的操作，用DOWNGRADE表示互斥锁到共享锁的转换操作。<ul><li>UPGRADE只能在加锁阶段使用，DOWNGRADE只能在解锁阶段使用</li></ul></li><li>当事务T提交一个READ(Q)操作时，系统先执行LOCK-S(Q)操作，然后再执行READ(Q)操作。当事务T提交一个WRITE(Q)操作时，先检查T是否已持有共享锁。是则先执行UPGRADE(Q)操作，再执行WRITE(Q)操作；否则先执行LOCK-X(Q)操作，再执行WRITE(Q)操作。</li><li>任何一个满足两段锁协议的合理调度都是冲突可串行的，但是，不是每组具有冲突可串行调度的事务都有一个满足两段锁协议的调度。</li></ul></li></ul><p><strong>基于时间戳的并发控制协议</strong></p><h6 id="实现决定事务的次序，最常见的方法是时间戳排序机制"><a href="#实现决定事务的次序，最常见的方法是时间戳排序机制" class="headerlink" title="实现决定事务的次序，最常见的方法是时间戳排序机制"></a>实现决定事务的次序，最常见的方法是时间戳排序机制</h6><p>对于系统中每个事务Ti，我们把一个唯一的固定时间戳和它联系起来，记为TS(Ti)，如果新引进Tj进入系统，则TS(Ti)&lt;TS(Tj)。</p><ul><li><p>事务的时间戳决定了串行化顺序</p></li><li><p>每个数据项Q需要与两个时间戳值相关联</p><ul><li>W-timestamp(Q)：表示成功执行write(Q)的所有事务的最大时间戳</li><li>R-timestamp(Q)：表示成功执行read(Q)的所有事务的最大时间戳</li></ul></li><li><p>优点：保证冲突可串行化、保证无死锁</p></li><li><p>缺点：一系列冲突的短事务可能引起长事务反复重启，导致长事务饿死</p></li><li><p>可能产生不可恢复的调度</p></li><li><p>Thomas写规则</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7.assets/image-20200706230829922.png" srcset="/img/loading.gif" alt="image-20200706230829922" style="zoom: 67%;"></p></li></ul><h6 id="本章重点：掌握事务的概念及性质、掌握事务调度和并发控制的概念、掌握基于锁的并发控制协议、掌握死锁的检测。"><a href="#本章重点：掌握事务的概念及性质、掌握事务调度和并发控制的概念、掌握基于锁的并发控制协议、掌握死锁的检测。" class="headerlink" title="本章重点：掌握事务的概念及性质、掌握事务调度和并发控制的概念、掌握基于锁的并发控制协议、掌握死锁的检测。"></a>本章重点：掌握事务的概念及性质、掌握事务调度和并发控制的概念、掌握基于锁的并发控制协议、掌握死锁的检测。</h6><h2 id="数据库恢复"><a href="#数据库恢复" class="headerlink" title="数据库恢复"></a>数据库恢复</h2><h5 id="数据库恢复的必要性"><a href="#数据库恢复的必要性" class="headerlink" title="数据库恢复的必要性"></a>数据库恢复的必要性</h5><ul><li>保证事务的原子性</li><li>发生故障后可以恢复到正确状态</li></ul><p>故障分类：</p><ul><li>事务故障<ul><li>逻辑故障：非法输入、找不到数据、溢出或超出资源限制</li><li>系统错误：系统进入不良状态，如死锁，使事务无法正常执行</li></ul></li><li>系统崩溃<ul><li>硬件故障/软件或系统漏洞导致易失性存储器内容丢失</li></ul></li><li>磁盘故障</li></ul><p>使用日志的数据库恢复技术</p><ul><li>数据库系统日志：记录有关事务的数据库操作信息的存储结构使数据库系统日志，简称日志</li><li>格式：<T, start> <T, commit> <T, abort> <T, x, v1, v2></T,></T,></T,></T,></li><li>为了保证日志在系统和磁盘发生故障时仍可使用，它必须永久地存在磁盘上</li></ul><p><strong>推迟更新技术</strong></p><h6 id="把所有数据库更新操作推迟到该事务提交时执行"><a href="#把所有数据库更新操作推迟到该事务提交时执行" class="headerlink" title="把所有数据库更新操作推迟到该事务提交时执行"></a>把所有数据库更新操作推迟到该事务提交时执行</h6><p>遵循下述推迟更新协议：</p><ul><li>每个事务达到提交点之前不能更新数据库</li><li>在一个事务的所有更新操作的对应日志记录永久写入存储器之前，该事务不能到达提交点。</li></ul><p>当一个事务达到提交点时，称该事务到达部分提交状态</p><ul><li>推迟更新协议保证，当一个事务部分提交时，该事务的所有更新状态都已经记录在了日志中</li><li>当一个事务部分提交时，推迟更新技术可以使用日志中有关该事务的数据库更新操作的信息更新数据库。如果一个事务部分提交之前异常结束或者发生系统故障，则有关该事务的信息会被删除。</li></ul><p>使用日记的数据库恢复技术：</p><ul><li><p>进行redo(T)操作。（redo操作必须时幂等的）</p></li><li><p>当系统发生故障并被修复以后，考察日志确定需要redo的事务T。（包含start和commit）</p></li><li>恢复过程如下：从后向前扫描，确定提交事务表和未提交事务表，对于前者执行redo，后者进行删除。</li></ul><p><strong>即时更新技术</strong></p><h6 id="允许事务直接更新数据库。处于活动状态的事务直接在数据库上实施的更新称为非提交更新。"><a href="#允许事务直接更新数据库。处于活动状态的事务直接在数据库上实施的更新称为非提交更新。" class="headerlink" title="允许事务直接更新数据库。处于活动状态的事务直接在数据库上实施的更新称为非提交更新。"></a>允许事务直接更新数据库。处于活动状态的事务直接在数据库上实施的更新称为非提交更新。</h6><p>即时更新协议：</p><ul><li>所有<T, x, v1, v2>型日志安全地、永久存储到存储器之前，事务T不能更新数据库。</T,></li><li>所有<T, x, v1, v2>型日志安全地、永久存储到存储器之前，不允许事务T提交。</T,></li></ul><p>即时更新技术需要如下两个操作：</p><ul><li>undo(T)</li><li>redo(T)</li><li>恢复处理过程如下：<ul><li>从后向前扫描，建立提交事务表和未提交事务表</li><li>对于提交事务表执行redo，对于未提交事务表执行undo并写<T, abort>日志记录表示撤销完成</T,></li></ul></li></ul><h5 id="使用检查点的数据库恢复技术"><a href="#使用检查点的数据库恢复技术" class="headerlink" title="使用检查点的数据库恢复技术"></a>使用检查点的数据库恢复技术</h5><h6 id="日志技术太耗时且恢复过程过长"><a href="#日志技术太耗时且恢复过程过长" class="headerlink" title="日志技术太耗时且恢复过程过长"></a>日志技术太耗时且恢复过程过长</h6><p>改进方式：在日志文件中增加检查点记录(checkpoint)</p><ul><li>恢复子系统在登陆日志文件期间动态地维护日志</li></ul><p>检查点执行过程如下：</p><ul><li>将当前位于主存的所有日志输出到稳定存储器</li><li>将所有修改的缓冲块输出到磁盘</li><li>将<checkpoint l\>输出到稳定的存储器，其中L是执行检查点时正在活跃的事务列表</checkpoint></li></ul><h6 id="在检查点执行过程中，不允许任何事务执行任何更新"><a href="#在检查点执行过程中，不允许任何事务执行任何更新" class="headerlink" title="在检查点执行过程中，不允许任何事务执行任何更新"></a>在检查点执行过程中，不允许任何事务执行任何更新</h6><p>建立检查点的时间：</p><ul><li>定期：预定时间间隔，如每隔一小时</li><li>不定期：遵循某种规则，如日志文件写满一半</li></ul><p>检查点技术的优点：高效、执行redo、undo时只需要考虑L以及<checkpoint l\>记录写道日志中后才开始执行的事务</checkpoint></p><p><strong>恢复过程</strong>：</p><ul><li>找到最后一条<checkpoint l \>记录</checkpoint></li><li>对于L及检查点之后开始的操作，没有commit或abort记录则undo；否则redo。</li></ul><h5 id="恢复算法"><a href="#恢复算法" class="headerlink" title="恢复算法"></a>恢复算法</h5><p>正常操作时，事务T的回滚执行如下操作：</p><ul><li>从后往前扫描，对于每个<T, x, v1, v2>的日志记录，把v1写入X，并往日志中写入一个特殊的只读日志记录<T, x, v1>，称为补偿日志记录，这样的记录不需要undo。</T,></T,></li><li>一旦发现<T,start>，就停止扫描并往日志中写入<T, abort></T,></T,start></li></ul><p>系统崩溃后的恢复：</p><ul><li>重做阶段：从最后一个检查点开始正向扫描，将undo-list初始设置为L，一旦遇到<T, x, v1, v1>或者<T, x, v2>则重做；一旦发现<T, start>则将T添加到undo-list；一旦发现commit和abort则将T从undo-list删除。</T,></T,></T,></li><li>撤销阶段：从尾部反向扫描，发现undo-list中的就undo。发现start就写入abort并将其从undo-list删掉。undo-list为空则结束。</li></ul><h5 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h5><ul><li><p>日志缓冲技术</p><ul><li>一个日志记录远小于存储器读写单位，单个进行开销过大</li><li><p>主存中设置缓冲区，其大小等于永久存储其的读写单位，缓冲区满一起永久写入存储器。</p></li><li><p>需增加如下协议：</p><ul><li>commit记录永久写入存储器后才可以进入提交状态</li><li>非commit型日志记录必须在commit型记录之前永久写入存储器</li><li>主缓冲区中的数据库数据必须在有关日志记录永久写入后才可以永久写入存储器中的数据库。</li></ul></li></ul></li><li><p>数据库缓冲技术<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F7.assets/image-20200708142014290.png" srcset="/img/loading.gif" alt="image-20200708142014290"></p></li></ul><h6 id="本章重点：掌握故障的分类、掌握使用日志的数据库恢复技术。"><a href="#本章重点：掌握故障的分类、掌握使用日志的数据库恢复技术。" class="headerlink" title="本章重点：掌握故障的分类、掌握使用日志的数据库恢复技术。"></a>本章重点：掌握故障的分类、掌握使用日志的数据库恢复技术。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统6</title>
    <link href="/2020/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6/"/>
    <url>/2020/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统6——查询处理&amp;查询优化。</p><a id="more"></a><h2 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h2><h4 id="关系代数操作算法"><a href="#关系代数操作算法" class="headerlink" title="关系代数操作算法"></a>关系代数操作算法</h4><h5 id="选择操作算法"><a href="#选择操作算法" class="headerlink" title="选择操作算法"></a>选择操作算法</h5><ul><li>简单选择操作算法：<ul><li>线性搜索算法<ul><li>顺序读取被操作关系的每个元组</li><li>测试该元组是否满足条件，满足则输出</li></ul></li><li>二元搜索算法<ul><li>条件：按该属性排序</li><li>$O(log(N))$</li></ul></li><li>主索引或者HASH搜索<ul><li>条件：主索引属性或者HASH属性上的相等比较</li></ul></li><li>使用主索引查找满足条件的元组<ul><li>条件：主索引属性上的非相等比较</li></ul></li><li>使用聚集索引查找满足条件的元组<ul><li>具有聚集索引的非键属性上的相等比较</li></ul></li><li>B+树和B树索引搜索算法</li><li>合取选择算法</li><li>使用复合索引的合取选择算法</li></ul></li></ul><h5 id="投影操作算法"><a href="#投影操作算法" class="headerlink" title="投影操作算法"></a>投影操作算法</h5><ul><li>若投影结果中包含码：存取R的所有元组一次即可完成</li><li>若不包含：需要删除重复元组。可利用排序算法实现投影操作</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703221314660.png" srcset="/img/loading.gif" alt="image-20200703221314660" style="zoom:67%;"></li></ul><h5 id="连接操作算法"><a href="#连接操作算法" class="headerlink" title="连接操作算法"></a>连接操作算法</h5><p>$\theta-$连接操作算法：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703222400631.png" srcset="/img/loading.gif" alt="image-20200703222400631" style="zoom:67%;"></p><p>等值连接操作算法：（这里讨论自然连接）</p><ul><li><p>循环嵌套链接（NLJ）</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703222903512.png" srcset="/img/loading.gif" alt="image-20200703222903512" style="zoom:50%;"></p><ul><li>优化：一次读入尽可能多的元组；使用尽可能多的内存块存放外层循环关系的元组；较小的作为外层。</li></ul></li></ul><ul><li><p>排序合并连接（Sort-Merge-Join）</p><p>​    <img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703223933668.png" srcset="/img/loading.gif" alt="image-20200703223933668" style="zoom: 50%;"></p></li></ul><ul><li><p>Hash-连接（Hash-Join）</p><p>​    <img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703224220132.png" srcset="/img/loading.gif" alt="image-20200703224220132" style="zoom:50%;"></p></li></ul><h5 id="集合操作算法"><a href="#集合操作算法" class="headerlink" title="集合操作算法"></a>集合操作算法</h5><h6 id="输入关系约束：具有相同的属性集合且属性的排列顺序也相同"><a href="#输入关系约束：具有相同的属性集合且属性的排列顺序也相同" class="headerlink" title="输入关系约束：具有相同的属性集合且属性的排列顺序也相同"></a>输入关系约束：具有相同的属性集合且属性的排列顺序也相同</h6><p>方法：利用排序算法在相同的键属性上排序两个操作关系，然后扫描排序后的关系，完成集合操作。</p><h6 id="本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法"><a href="#本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法" class="headerlink" title="本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法"></a>本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法</h6><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h6 id="使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。"><a href="#使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。" class="headerlink" title="使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。"></a>使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。</h6><h5 id="关系表达式的等价转换规则"><a href="#关系表达式的等价转换规则" class="headerlink" title="关系表达式的等价转换规则"></a>关系表达式的等价转换规则</h5><p>关系代数等价转换规则：</p><ul><li>选择串接率<ul><li>$\sigma_{c1 and…and cn }(E) \equiv \sigma_{c1}(\sigma_{c2}(…(\sigma_{cn}(E))))$</li></ul></li><li>选择交换律<ul><li>$\sigma_{c1}(\sigma_{c2}(E)) \equiv \sigma_{c2}(\sigma_{c1}(E))$</li></ul></li><li>投影交换律<ul><li>$\Pi_{L1}(\Pi_{L2}(…(\Pi_{Ln}(E))…)) \equiv \Pi_{L1}(E)$</li></ul></li><li>选择投影交换律<ul><li>$\Pi_{L}(\sigma_C(E)) \equiv \sigma_C(\Pi_{L}(E)) $ —— C中只涉及L中属性</li><li>$\Pi_{L}(\sigma_C(E)) \equiv \Pi_{L}(\sigma_C(\Pi_{L,B1,B2,…,Bm}(E)))$ ——还涉及其他属性</li></ul></li><li>连接和笛卡尔积的交换律</li><li>集合操作的交换律</li><li>连接、笛卡尔积和集合操作的结合律</li><li>选择、连接和笛卡尔乘积的分配律</li><li>投影、连接和笛卡尔乘积的分配律</li><li>选择与集合操作的分配律</li><li>投影与集合操作的分配律</li><li>其他</li></ul><h5 id="表达式结果大小的估计"><a href="#表达式结果大小的估计" class="headerlink" title="表达式结果大小的估计"></a>表达式结果大小的估计</h5><h6 id="一个操作的代价依赖于它的输入大小和其他统计信息"><a href="#一个操作的代价依赖于它的输入大小和其他统计信息" class="headerlink" title="一个操作的代价依赖于它的输入大小和其他统计信息"></a>一个操作的代价依赖于它的输入大小和其他统计信息</h6><ul><li><p>数据库系统的统计信息</p><ul><li>$n_r$：关系r的元组数</li><li>$b_r$：包含关系r中元组的磁盘块数</li><li>$l_r$：关系r中每个元组的字节数</li><li>$f_r$：关系r的块因子（一个磁盘块中可以容纳r中元组的个数）</li><li>$V(A,r)$：关系r中属性A中出现的非重复值的个数</li></ul></li><li><p>如果假设关系r在物理上存储于一个文件中，则 $b_r = \lceil n_r/ f_r\rceil$</p></li><li><p>当r中A属性上的取值分布是均匀的，运算结果的大小估计如下：</p><ul><li><p>投影$\Pi_A(r)$ ：$V(A,r)$</p></li><li><p>选择$\sigma_{A=a}(R)$： $n_r/V(A,r)$</p></li><li><p>$\sigma_{A \leq v}(R)$： </p><ul><li>$if v &lt; min(A,r)$：0</li><li>$if v &gt; max(A,r)：n_r$</li><li>else：$n_r \times [v-min(A,r)]/[max[A,r]-min(A,r)]$ </li></ul></li><li><p>合取$\sigma_{\theta_1 \wedge…\wedge \theta_k}(R)$： $n_r \times分别的选择估计结果相乘/ n_r^k$</p></li><li><p>析取：$(1-(1-计算结果_1/n_r)\times……)\times n_r$</p></li><li><p>取反$\sigma_{\urcorner\theta}(r)$：无空值——$n_r-s_\theta$</p><p>​                        右空值——$n_r-n_{null}-s_\theta$</p></li><li><p>笛卡尔积：元素个数之积，每个元组占$l_r+l_s$个字节</p></li><li><p>自然连接：RS交集为空：类似笛卡尔积的结果</p><p>​                   RS交集为R的码：小于等于$n_s$</p><p>​                   交集为S中参照R的外码：$n_s$</p><p>​                   不是任何的码：$min(n_r\times n_s/V(A,s),n_s\times n_r/V(A,r))$</p></li><li><p>聚集：$V(A,r)$</p></li><li><p>集合运算：类似于合取、析取、取反的估计方法</p></li><li><p>外连接（结果上界）：</p><ul><li>r左外连接s：自然连接估值+$n_r$</li><li>r右外连接s：自然连接估值+$n_s$</li><li>r全外连接s：自然连接估值+$(n_r+n_s)$</li></ul></li></ul></li><li><p>当r中A属性上的取值分布不均匀的，可以采用直方图等统计方法统计方法进行结果大小估计。</p></li></ul><h5 id="启发式关系代数优化算法"><a href="#启发式关系代数优化算法" class="headerlink" title="启发式关系代数优化算法"></a>启发式关系代数优化算法</h5><ul><li><p>启发式代数优化规则</p><h6 id="给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）"><a href="#给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）" class="headerlink" title="给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）"></a>给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）</h6><ul><li><p>选择和投影操作尽早执行</p></li><li><p>把某些选择操作与笛卡尔积相结合，形成一个连接操作</p></li><li>同时执行相同关系上的多个选择和投影操作</li><li>把投影操作与连接操作结合起来执行</li><li>提取公共表达式（如果一个反复出现的公共表达式结果不是很大，且从外存读入的时间小于计算时间，可以组织计算一次并存储结果）</li></ul></li><li><p>启发式代数优化算法</p><ul><li>构造查询的内部表示是查询处理的第一步。给定一个用高级语言定义的查询，需要两步来构造该查询的内部表示。<ul><li>把高级语言定义的查询转换为关系代数表达式<ul><li>使用from从句中的关系构造笛卡尔积，然后再这个基础上构造选择操作，最后构造投影操作</li></ul></li><li>把关系代数表达式转化为查询树</li></ul></li><li>算法流程：<ul><li>把每个选择操作$\sigma_{C1 and….and Cn}(E)$转化为$\sigma_{C1}(…(\sigma_{Cn}(E))…)$</li><li>把每个选择操作移到尽可能靠近叶结点</li><li>把每个投影操作尽可能靠近叶结点</li><li>把串接的多个选择或多个投影操作组合为单个的选择或投影操作</li><li>重新安排叶结点，使既有最小选择操作的叶结点最先执行</li><li>组合笛卡尔积和相继的选择操作形成连接操作</li><li>把最后的查询树划分为多个子树，使得每个子树上的操作可以由单个存取程序一次完成，划分方法如下：<ul><li>每个耳目操作在且仅在一个子树中</li><li>如果二目操作a在子树t中，而且从叶到根的方向的路径b$\rightarrow$a是仅包含一目操作的最长路径，则b$\rightarrow$a也包含在t中</li></ul></li><li>产生一个计算最后查询树的程序，每一步计算一个子树</li></ul></li></ul></li></ul><p>基于复杂性估计的查询优化算法</p><p>两个阶段：</p><ul><li>用启发式优化算法产生逻辑上优化的关系代数表达式或查询计划p</li><li>为p中每个关系代数操作选择具有最小复杂性的实现算法，确定p的优化执行策略p(A)</li><li>影响查询执行效率的主要因素是磁盘存取块数</li></ul><h6 id="本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。"><a href="#本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。" class="headerlink" title="本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。"></a>本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统5</title>
    <link href="/2020/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5/"/>
    <url>/2020/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统5——物理存储结构。</p><a id="more"></a><h2 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h2><h5 id="数据库存储设备"><a href="#数据库存储设备" class="headerlink" title="数据库存储设备"></a>数据库存储设备</h5><p>高速缓冲存储器（Cache）：最快价格昂贵的存储介质，由计算机的硬件管理</p><p>主存储器：存放可处理数据，快、贵、数据易丢失</p><p>快闪存储器：断电故障可保存，相对价低，读速几乎与贮存想要，写稍慢，擦除更慢——固态硬盘</p><p>磁盘存储器：长期存储，进行操作时需先读入主存、慢</p><ul><li>多个磁盘组装成磁盘组，每个磁盘表面由多个磁道组成（数据存储在磁道上），每个磁道分为多个扇区（磁盘块），在磁盘组上所有磁盘面具有相同直径的磁道的集合称为一个柱面。</li><li>磁盘存储器由磁盘和驱动器构成，磁头和磁臂。分类：固定头磁盘存储器和活动头磁盘存储器</li><li>寻址方式：柱面号+面号+扇区号</li><li>代价：寻找使劲按+旋转延迟+传输时间</li><li>磁盘缓冲区理技术：最近最少使用、立即丢弃、最近最多使用</li><li>磁盘扫描策略：先来先服务、近者优先、全程移动、移动扫描、分组扫描、间歇式全程扫描</li><li>磁盘容错技术——基于磁盘冗余技术的策略（独立磁盘冗余阵列）<ul><li>RAID1：一对一</li><li>RAID4：一个冗余盘完成n个的奇偶校验。所有磁盘同一位置1的个数是偶数则为0，否则1。 问题：冗余盘读写次数太多</li><li>RAID5：每个磁盘作为某些磁盘的冗余磁盘</li></ul></li></ul><p>光学存储器：比磁盘慢很多</p><p>磁带存储器：顺序存储访问、十分慢、十分便宜（磁带驱动器贵）</p><h5 id="磁盘文件"><a href="#磁盘文件" class="headerlink" title="磁盘文件"></a>磁盘文件</h5><p>数据项——属性值</p><p>文件记录——元组</p><p>文件块——记录集合、一个磁盘块</p><p>文件——一个关系</p><ul><li><p>种类：无需文件、有序文件、索引文件、Hash文件</p></li><li><p>文件的存储方法：</p><ul><li><p>连续存储方法：按文件块顺序把文件存储到连续的磁盘块上</p><ul><li>存取整个文件的效率高，但扩充困难</li></ul></li><li><p>链接存储方法</p><ul><li>增加指向像一个文件块所在的磁盘块的地址指针</li><li>便于扩充，但整个读取慢</li></ul></li><li><p>索引存储方法</p><ul><li>在磁盘上存储一个或多个索引块，每个索引块包含指向文件块的指针</li><li>查询处理高效</li></ul></li></ul></li></ul><h5 id="Hash文件"><a href="#Hash文件" class="headerlink" title="Hash文件"></a>Hash文件</h5><p>简单HASH</p><ul><li>桶溢出（文件记录在Hash属性上分布不均匀）</li><li>解决：多重Hash（设置溢出处理Hash函数）、链接法（每个桶设置一个磁盘块链表，用于超出部分存储）</li><li>缺点：只能有效地支持在Hash码上具有相等比较的数据操作；文件记录少时浪费大量存储空间；磁盘块链过长时影响记录存取效率。</li></ul><p>动态Hash</p><ul><li>Hash桶与磁盘块一一对应</li><li>Hash桶数量不固定，不断分裂</li><li>二叉树表示：内节点左0右1，叶节点存储指针<ul><li>分裂&amp;合并</li></ul></li><li>优点：查找记录时只需查找一个存储块</li><li>缺点：同增长速度快，可能内存放不下，影响其他数据，波动较大</li></ul><h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><p>索引时一种数据结构，通常是有序文件</p><p>索引也是文件——索引文件</p><ul><li>索引文件的记录称为索引记录（项）</li><li>索引记录包括两个域：搜索码&amp;指针</li><li><p>索引文件一般远小于数据文件</p></li><li><p>多级索引</p></li><li><p>按结构分类：</p><ul><li>稀疏索引：所有记录按关键字值分组（管理方便但更新代价高）<ul><li>主索引常常是稀疏索引</li></ul></li><li>稠密索引：每个记录一个索引项（有序操作方便但复杂）</li></ul></li><li><p>按索引域特点分：</p><ul><li>主索引（常常是聚集索引）</li><li>辅助索引（一定是稠密索引）</li></ul></li></ul><h5 id="B-树和B树文件索引"><a href="#B-树和B树文件索引" class="headerlink" title="B+树和B树文件索引"></a>B+树和B树文件索引</h5><p>略</p><h6 id="本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B-树的索引结构。"><a href="#本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B-树的索引结构。" class="headerlink" title="本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B+树的索引结构。"></a>本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B+树的索引结构。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统4</title>
    <link href="/2020/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4/"/>
    <url>/2020/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统4——设计篇：概念数据库设计、逻辑数据库设计、物理数据库设计。</p><a id="more"></a><h2 id="数据库设计概述与需求分析"><a href="#数据库设计概述与需求分析" class="headerlink" title="数据库设计概述与需求分析"></a>数据库设计概述与需求分析</h2><p>概念：对于一个给定的应用领域，设计优化的数据库逻辑和物理结构，使之满足用户的<strong>信息管理要求</strong>和<strong>数据操作要求</strong>，有效地支持各种应用系统的开发和运行。</p><ul><li>信息管理要求：在数据库中应该存储和管理哪些数据对象</li><li>数据操作要求：对数据对象需要进行哪些操作</li></ul><h5 id="数据库设计目标"><a href="#数据库设计目标" class="headerlink" title="数据库设计目标"></a>数据库设计目标</h5><p>为用户和各种应用系统提供一个基础设施和高效的运行环境</p><ul><li>数据信息完整、冗余度低</li><li>存取效率高</li><li>运行管理效率高</li></ul><h5 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h5><h6 id="中心：用户需求"><a href="#中心：用户需求" class="headerlink" title="中心：用户需求"></a>中心：用户需求</h6><p>数据库设计包括：</p><ul><li>设计数据库模式</li><li>设计访问和更新数据的程序</li><li>设计数据访问的安全模式</li></ul><p>各级模式形成过程：</p><p>需求分析$\rightarrow$概念数据库设计$\rightarrow$逻辑数据库设计$\rightarrow$物理数据库设计</p><ul><li>需求分析：综合应用需求</li><li>概念数据库设计：形成概念模式（E-R图）</li><li>逻辑数据库设计：首先将E-R图转换成数据模型（如关系模型），形成逻辑模式，再根据安全性和用户需求形成外模式</li><li>物理数据库设计：进行物理存储安排</li></ul><h2 id="概念数据库设计"><a href="#概念数据库设计" class="headerlink" title="概念数据库设计"></a>概念数据库设计</h2><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>设计任务：</p><ul><li>概念数据库模式设计</li><li>事务设计</li></ul><p>概念数据库模式独立于任何数据库管理系统，不能直接用于数据库的实现。</p><p>用于概念数据库设计的高级数据模型——实体联系模型</p><h5 id="实体联系（E-R）模型"><a href="#实体联系（E-R）模型" class="headerlink" title="实体联系（E-R）模型"></a>实体联系（E-R）模型</h5><p>三个主要元素：实体、属性、联系</p><p><strong>实体</strong></p><ul><li>ER模型的基本对象</li><li>每个实体都有一组特征或性质——<strong>属性</strong><ul><li>实体属性的一组特定值确定了一个特定的实体</li><li>实体的属性值是数据库中存储的主要数据</li></ul></li><li><strong>实体集</strong>：相同类型的实体的集合<ul><li>实体集不必互不相交</li></ul></li></ul><p><strong>属性</strong></p><ul><li>单值属性、多值属性<ul><li>一些属性的取值可能是多个（eg：联系方式）</li></ul></li><li>简单属性、复合属性<ul><li>符合熟悉具有层次结构（eg：家庭住址可再分）</li></ul></li><li>派生属性<ul><li>可以由其他属性导出（eg：年龄可由生日导出）</li></ul></li><li>码的概念</li></ul><p><strong>联系</strong></p><ul><li><p>不同实体集的实体之间存在的某种关联</p></li><li><p><strong>联系集</strong>：同类联系的集合</p><ul><li>称一个联系集所关联的实体集的数量为这个联系集的阶</li><li>阶为n的联系集称为n元联系集</li><li>联系集的属性</li></ul></li><li><p>约束</p><ul><li>映射基数<ul><li>一个实体通过一个联系能关联的实体的个数<ul><li>一对一、一对多、多对多</li></ul></li></ul></li><li>参与约束<ul><li>全城关联约束<ul><li>eg：每个教研室必须属于一个系，则教研室实体集与属于联系集有全程关联约束</li></ul></li><li>部分关联约束<ul><li>eg：不是每个教师都是主任</li></ul></li></ul></li></ul></li><li><p>弱实体集</p><ul><li><p>必须有一个或多个属性，使得这些属性可以与主实体集的码相结合，形成相应弱实体的码</p><ul><li>上述属性称为弱实体集的<strong>部分码</strong></li><li>eg：父亲实体集与孩子实体集（不同父亲的孩子名字可以相同，同一个父亲的孩子姓名一定不同）</li></ul></li></ul></li></ul><p><strong>实体联系图（ER图）</strong></p><p>这部分略了先qvq…</p><p><strong>事务设计</strong></p><ul><li><p>事务：一个或多个数据操作构成的集合，这组操作满足原子性</p></li><li><p>设计任务：定义事务功能、说明事务的输入输出。</p></li></ul><h6 id="本章重点：实体联系模型、实体联系图、账务概念数据库设计方法"><a href="#本章重点：实体联系模型、实体联系图、账务概念数据库设计方法" class="headerlink" title="本章重点：实体联系模型、实体联系图、账务概念数据库设计方法"></a>本章重点：实体联系模型、实体联系图、账务概念数据库设计方法</h6><h2 id="逻辑数据库设计"><a href="#逻辑数据库设计" class="headerlink" title="逻辑数据库设计"></a>逻辑数据库设计</h2><p>设计任务：把概念数据库设计产生的概念数据库模式变换为逻辑数据库模式。</p><ul><li>ER图$\rightarrow$关系表</li></ul><p>逻辑数据库设计的步骤</p><ul><li>形成初始关系数据库模式</li><li>关系模式规范化</li><li>关系模式优化</li><li>定义关系上的完整性和安全性约束</li><li>子模式定义</li><li>性能估计</li></ul><h5 id="形成初始关系模式"><a href="#形成初始关系模式" class="headerlink" title="形成初始关系模式"></a>形成初始关系模式</h5><ul><li>普通实体集变换</li><li>弱实体的变换<ul><li>主实体集的码和弱实体集的部分码构成关系的主码</li></ul></li><li>多值属性的变换<ul><li>为每个多值属性建立一个关系</li></ul></li><li>实体间联系的变换<ul><li>一对一：在其中一个关系中增加有关信息、或建立单独关系</li><li>一对多：可以不建立新关系、也可以建立</li><li>多对多：建立新关系</li><li>n元联系的变换：和多对多类似</li></ul></li></ul><h5 id="关系模式规范化"><a href="#关系模式规范化" class="headerlink" title="关系模式规范化"></a>关系模式规范化</h5><h6 id="为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题"><a href="#为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题" class="headerlink" title="为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题"></a>为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题</h6><p><strong>函数依赖</strong></p><ul><li><p>定义：设R是一个关系模式，U是R的属性集合，X和Y是U的子集。对于R的任意实例ｒ，ｒ中任意两个元组t1和t2，如果t1[X]=t2[X]，则t1[Y]=t2[Y]，我们称X函数地确定Y，或Y函数依赖于X，记作X→Y。</p><ul><li>如果X→Y且Y不是X的子集，则称X→Y是<strong>非平凡函数依赖</strong></li><li>如果X→Y，称X为这个函数依赖的<strong>决定属性集</strong></li></ul></li><li><p>完全函数依赖与部分函数依赖</p><ul><li>X取任何真子集都不能使依赖成立——完全函数依赖</li></ul></li><li><p>传递地函数依赖</p></li><li><p>各种码：</p><ul><li>超码：可以唯一地识别关系的元组</li><li>候选码：超码且不能取真子集</li><li>主码：被选中的孩子！（x候选码）</li><li>键属性：包含在某个候选码中的属性</li><li>非键属性：不包含在任何候选码中的属性</li><li>全键：候选码包含所有属性</li><li>外码：某个属性子集合是另一个关系模式的主码</li></ul></li></ul><p><strong>函数依赖的公理系统</strong></p><h6 id="Armstrong公理系统——模式分解算法的理论基础"><a href="#Armstrong公理系统——模式分解算法的理论基础" class="headerlink" title="Armstrong公理系统——模式分解算法的理论基础"></a>Armstrong公理系统——模式分解算法的理论基础</h6><ul><li><p>设R是一个具有属性集合U的关系模式，F是R上的函数依赖集合。如果对于R的任何一个使F称的关系实例r，函数依赖X→Y都成立，则称F逻辑蕴含X→Y。</p></li><li><p>Armstrong公理系统</p><ul><li>自反率：$Y \subseteq X \subseteq U,$则 X→Y 为F所蕴含。</li><li>增广率：若 X→Y 为F所蕴含，且$Z \subseteq U$，则XZ→YZ为F所蕴含。</li><li>传递率：若 X→Y 及 Y→Z 为F所蕴含，则 X→Z为F所蕴含。</li><li>导出规则：<ul><li>合并规则（左部相同右部可合并）</li><li>伪传递规则（X→Y，WY→Z，则XW→Z）</li><li>分解规则（Z $\subseteq$ Y，X→Y，则X→Z）</li></ul></li></ul></li><li><p>闭包：大概就是给的能推出来的都加进去</p></li><li><p>对于给定关系模式和函数依赖集，可将属性分为四类</p><ul><li>L类：仅出现在函数依赖左部<ul><li>必为任一候选码的成员</li></ul></li><li>R类：仅出现在右部<ul><li>不在任何候选码中</li></ul></li><li>N类：在两边都未出现<ul><li>必包含在任一候选码中</li></ul></li><li>LR类：两边都出现</li><li>推论：如果X是N、L两类属性组成的属性集且X的闭包包含了R的全部属性，则X是R的候选码</li></ul></li><li><p>极小函数依赖集：</p><ul><li>F中任一函数依赖右部仅含有一个属性</li><li>不存在X→Y使得F与F-{X→Y}等价</li><li>不存在X→Y，X有真子集Z使得F-{X→Y}∪{Z→Y}与F等价</li><li>极小函数依赖集不唯一</li></ul></li><li><p>计算极小函数依赖集的方法:</p><ul><li>拆分右部</li><li>逐一去掉某函数依赖（X→Y）判断剩余是否仍满足X→Y（计算闭包）</li><li>逐一判断能否去掉右部某一部分使其仍成立</li></ul></li></ul><p><strong>关系模式的规范形式</strong></p><h6 id="1NF-supset-2NF-supset-3NF-supset-BCNF-supset-4NF"><a href="#1NF-supset-2NF-supset-3NF-supset-BCNF-supset-4NF" class="headerlink" title="$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF$"></a>$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF$</h6><ul><li><p>第一范式（1NF）</p><ul><li>每个属性的值域是不可分的简单数据项的集合</li><li>问题<ul><li>插入异常、删除异常、数据冗余度大、修改复杂</li></ul></li><li>存在部分函数依赖</li></ul></li><li><p>第二范式（2NF）</p><ul><li>每一个非键属性都完全函数依赖于候选码</li><li>可以由1NF模式分解得到多个2NF，减轻了问题。</li><li>存在非键属性对候选码的传递函数依赖</li></ul></li><li><p>第三范式（3NF）</p><ul><li>任何一个非键属性都不传递依赖与任何候选码</li><li>仍不能完全消除问题</li><li>键属性部分依赖于候选码</li></ul></li><li><p>BC范式（BCNF）</p><ul><li>1NF且对于每个函数依赖，左部必为候选码</li><li>性质：<ul><li>所有非键属性都完全依赖于每个候选码</li><li>所有键属性都完全依赖于不包含它的候选码</li><li>没有任何属性依赖于非键的一组属性</li></ul></li><li>满足BCNF一定满足3NF</li><li>效处理插入和删除异常</li></ul></li></ul><p><strong>关系模式的分类</strong></p><ul><li>静态关系：一旦数据已经加载，只能查询不能插入删除更新<ul><li>需满足1NF</li></ul></li><li>动态关系：经常插入删除更新<ul><li>需满足3NF</li></ul></li></ul><h6 id="不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）"><a href="#不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）" class="headerlink" title="不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）"></a>不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）</h6><p>分解时的要求：既可以通过自然连接恢复为原来的关系（无损连接性），也不丢失函数依赖</p><p>判断无损连接性：分解后的函数依赖的并集是否完全包含原本的函数依赖集</p><p><strong>分解为具有无损连接和保持函数依赖的3NF</strong></p><ul><li>根据绩效函数依赖及合并左部相同部分</li><li>分解后判断是否包含候选码，不包含加入</li><li>合并包含关系</li></ul><h5 id="关系模式优化"><a href="#关系模式优化" class="headerlink" title="关系模式优化"></a>关系模式优化</h5><h6 id="提高数据的操作效率和存储空间利用率"><a href="#提高数据的操作效率和存储空间利用率" class="headerlink" title="提高数据的操作效率和存储空间利用率"></a>提高数据的操作效率和存储空间利用率</h6><p>常用分解方法</p><ul><li>水平分解：把元组分成若干个子集，定义每个子集为一个子关系</li><li>垂直分解：需要注意保持无损连接性和函数依赖</li></ul><h5 id="定义关系上的完整性和安全性约束"><a href="#定义关系上的完整性和安全性约束" class="headerlink" title="定义关系上的完整性和安全性约束"></a>定义关系上的完整性和安全性约束</h5><ul><li>完整性约束<ul><li>属性上的完整性约束</li><li>多个属性键的完整性约束</li><li>不同关系模式的完整性约束</li></ul></li><li>安全性约束<ul><li>属性上的安全性约束</li><li>关系模式上的安全性约束</li></ul></li></ul><h5 id="子模式定义"><a href="#子模式定义" class="headerlink" title="子模式定义"></a>子模式定义</h5><p>利用视图定义外模式</p><ul><li>属性重命名</li><li>不同级别不同视图</li><li>简化用户使用</li></ul><h5 id="性能估计"><a href="#性能估计" class="headerlink" title="性能估计"></a>性能估计</h5><h6 id="对时间复杂性和空间复杂性进行估算"><a href="#对时间复杂性和空间复杂性进行估算" class="headerlink" title="对时间复杂性和空间复杂性进行估算"></a>对时间复杂性和空间复杂性进行估算</h6><p>三个测度：逻辑记录存取数、信息传输量、存储空间占用量</p><h6 id="本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。"><a href="#本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。" class="headerlink" title="本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。"></a>本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。</h6><h2 id="物理数据库设计"><a href="#物理数据库设计" class="headerlink" title="物理数据库设计"></a>物理数据库设计</h2><h6 id="设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许"><a href="#设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许" class="headerlink" title="设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许"></a>设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许</h6><p>设计步骤</p><ul><li>分析影响物理数据库设计因素</li><li>为关系模式选择存取方法</li><li>设计关系、索引等数据库文件的物理存储结构</li></ul><p>常用存取方法</p><ul><li>聚集方法<ul><li>把经常进行连接操作的多个关系的记录以链接属性为中心分类存储</li><li>一个物理数据库可以由多个聚集存储，但是一个关系只能加入一个聚集存储</li><li>选择方法<ul><li>确定聚集关系组：<ul><li>经常连接操作的关系</li><li>一个关系的某组属性经常出现在相等比较条件中</li><li>某一（组）属性实例重复率很高</li><li>取消不必要关系：经常全关系扫面的，更细删除操作远大于连接操作的。</li></ul></li><li>确定优化的聚集方案</li></ul></li></ul></li><li>索引方法<ul><li>确定候选索引方法：<ul><li>经常出现在查询操作条件</li><li>经常作为聚集函数参数</li><li>经常在连接操作的连接条件中</li><li>经常作为投影属性使用</li></ul></li><li>索引存取方法的选择</li></ul></li><li>HASH方法<ul><li>选择规则：经常出现在相等连接操作条件中或相等比较选择条件中，且满足：<ul><li>如果关系大小可预知且不变</li><li>如果关系大小动态改变且数据库管理系统提供了动态HSAH存取方法</li></ul></li></ul></li></ul><p>物理存储结构设计</p><p>确定如何在磁盘存储器上存储关系、索引和聚集，使得空间利用率最大化，数据操作引起的系统开销最小化。</p><h6 id="本章重点：掌握数据库物理存储结构和存取方法的设计"><a href="#本章重点：掌握数据库物理存储结构和存取方法的设计" class="headerlink" title="本章重点：掌握数据库物理存储结构和存取方法的设计"></a>本章重点：掌握数据库物理存储结构和存取方法的设计</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统3</title>
    <link href="/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3/"/>
    <url>/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统3——结构化查询语言SQL。</p><a id="more"></a><h2 id="SQL查询语言概览"><a href="#SQL查询语言概览" class="headerlink" title="SQL查询语言概览"></a>SQL查询语言概览</h2><h5 id="SQL语言的几个部分"><a href="#SQL语言的几个部分" class="headerlink" title="SQL语言的几个部分"></a>SQL语言的几个部分</h5><p>数据定义语言（DDL）：提供定义关系模式、删除关系以及修改关系模式的命令</p><p>数据操纵语言（DML）：提供从数据中查询信息、插入删除修改元组的能力</p><p>完整性：SQL DDL 包括定义完整性的约束命令</p><p>视图定义：SQL DDL 包括定义视图的命令</p><p>事务控制：定义事务的开始和结束</p><p>嵌入式SQL和动态SQL：如何将SQL陷入到通用编程语言</p><p>授权：SQL DDL 包括定义访问权限的命令</p><p>SQL语言特点：</p><ul><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>简便易学易用</li></ul><h2 id="SQL数据定义"><a href="#SQL数据定义" class="headerlink" title="SQL数据定义"></a>SQL数据定义</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215355571.png" srcset="/img/loading.gif" alt="image-20200629215355571"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215530535.png" srcset="/img/loading.gif" alt="image-20200629215530535"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215715100.png" srcset="/img/loading.gif" alt="image-20200629215715100"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215841656.png" srcset="/img/loading.gif" alt="image-20200629215841656"></p><h2 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h2><p>单表查询</p><ul><li>最简单、仅涉及一个表</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629221054876.png" srcset="/img/loading.gif" alt="image-20200629221054876" style="zoom: 67%;"></li></ul><p>连接查询</p><ul><li>同时涉及到多个表的查询</li><li>连接条件</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629221144057.png" srcset="/img/loading.gif" alt="image-20200629221144057" style="zoom:67%;"></li></ul><p>嵌套子查询</p><ul><li>将一个查询块嵌套在另一个查询块的where、from、having语句条件中的查询</li><li>由里向外处理</li><li>子查询不能使用order by</li><li>有些嵌套查询可以用连接运算替代</li></ul><p>集合查询</p><ul><li>并（union）、交（intersect）、差（except）</li><li>参加集合操作的各结果表列数和对应数据类型必须相同</li></ul><h2 id="SQL数据库的修改"><a href="#SQL数据库的修改" class="headerlink" title="SQL数据库的修改"></a>SQL数据库的修改</h2><h5 id="SQL语言数据更新机制"><a href="#SQL语言数据更新机制" class="headerlink" title="SQL语言数据更新机制"></a>SQL语言数据更新机制</h5><ul><li>DBMS在执行插入、修改及删除语句时会检查元组是否会破坏表上已定义的完整性规则</li></ul><h2 id="SQL事务"><a href="#SQL事务" class="headerlink" title="SQL事务"></a>SQL事务</h2><p>事务是由查询或更新语句序列组成的</p><ul><li>Commit：提交当前事务（永久保存）</li><li>Rollback：回滚当前事务（撤销该事务中所有SQL语句对数据库的更新）</li><li>事务具有原子性</li><li>定义语句：begin atomic … end</li></ul><h2 id="SQL触发器"><a href="#SQL触发器" class="headerlink" title="SQL触发器"></a>SQL触发器</h2><p>触发器（trigger）</p><ul><li>一条语句，对数据修改时自动执行</li><li>设置触发器机制的两个要求：<ul><li>指明执行条件</li><li>指明触发器动作</li></ul></li><li>一旦把一个触发器输入数据库，只要指定的事件发生，相应条件满足，数据库系统就有责任执行它</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629223204596.png" srcset="/img/loading.gif" alt="image-20200629223204596" style="zoom: 50%;"></li></ul><h2 id="SQL数据库授权机制"><a href="#SQL数据库授权机制" class="headerlink" title="SQL数据库授权机制"></a>SQL数据库授权机制</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629224049807.png" srcset="/img/loading.gif" alt="image-20200629224049807" style="zoom:67%;"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629224100841.png" srcset="/img/loading.gif" alt="image-20200629224100841" style="zoom:67%;"></p><h2 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h2><p>嵌入式SQL</p><ul><li>可以在程序设计语言中使用的SQL语言</li><li>这种程序设计语言被称为宿主语言</li></ul><p>嵌入SQL语句的宿主语言源程序的编译执行</p><ul><li>预编译截断</li><li>编译阶段</li><li>连接装配阶段</li><li>执行阶段</li></ul><p>宿主语言与SQL语言之间的数据传输</p><ul><li>宿主变量：嵌入式SQL可以引用的语言变量</li><li>游标：存储查询结果集合<ul><li>每个查询语句对应于一个游标</li><li>定义游标、打开游标、从游标读拆线呢结果、关闭游标</li></ul></li></ul><h6 id="本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。"><a href="#本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。" class="headerlink" title="本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。"></a>本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>情感分析读书笔记1</title>
    <link href="/2020/03/18/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2020/03/18/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>​        情感分析课程作业——情感分析与观点挖掘读书笔记——第一、二章</p><a id="more"></a><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h6 id="情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。"><a href="#情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。" class="headerlink" title="情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。"></a>情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。</h6><h3 id="1-1-情感分析的应用"><a href="#1-1-情感分析的应用" class="headerlink" title="1.1 情感分析的应用"></a>1.1 情感分析的应用</h3><p>在生活中，我们寻求他人观点用以：</p><ul><li>个人对商品的选择与购买</li><li>商家了解产品或服务的评价</li><li>政治选举</li></ul><p>为什么要使用情感分析：</p><ul><li>网络上用于发表观点的不同的网站众多</li><li>观点可能隐藏在长篇大论之中</li><li>独自筛选总结困难，因为需要自动的情感分析系统</li></ul><p><strong>意见分析器</strong>（<em>Opinion</em> <em>Parser</em>）</p><h3 id="1-2-情感分析研究"><a href="#1-2-情感分析研究" class="headerlink" title="1.2 情感分析研究"></a>1.2 情感分析研究</h3><h4 id="1-2-1-分析的不同层次"><a href="#1-2-1-分析的不同层次" class="headerlink" title="1.2.1 分析的不同层次"></a>1.2.1 分析的不同层次</h4><p>三个主要层次：</p><ul><li>文档层次：从文章整体角度考虑情感倾向。不适用于评价或比较多个物体的文章。</li><li>句子层次：判断句子的观点（积极、消极、中立），类似于主观性分类。</li><li>实体与方面层次：从某一实体或者某实体的某方面进行分析。</li></ul><p>对于观点的分类：</p><ul><li>普通评论</li><li>比较性评论</li></ul><h4 id="1-2-2-情感词典及相关问题"><a href="#1-2-2-情感词典及相关问题" class="headerlink" title="1.2.2 情感词典及相关问题"></a>1.2.2 情感词典及相关问题</h4><p>尽管情感词汇对于情感分析来说是十分重要的，但是只是使用它们是不够充分的：</p><ul><li>有些词汇不能明确的区分为积极或消极；</li><li>有些句子虽然包含情感词汇，但是只是客观陈述，不表达情感；</li><li>有些句子虽然不包含情感词汇，但是表达出了某些情感；</li><li>存在反语。</li></ul><h4 id="1-2-3-自然语言处理问题"><a href="#1-2-3-自然语言处理问题" class="headerlink" title="1.2.3  自然语言处理问题"></a>1.2.3  自然语言处理问题</h4><p>​        情感分析涉及到自然语言处理的各个方面，许多NLP中的未解问题使得情感分析更加困难。但是由于情感分析不需要完整的了解句子的语义，只需要理解其中的某些方面（观点的积极与消极等），因而也为NLP的研究者们提供了一定的平台。</p><h3 id="1-3-垃圾观点检测"><a href="#1-3-垃圾观点检测" class="headerlink" title="1.3 垃圾观点检测"></a>1.3 垃圾观点检测</h3><p>​        由于人们可以匿名发表一些评论，虽然因此可能会出现一些非常有价值的观点，但是这也导致了恶意评论掩盖真实评论的情况。如果我们要发现这些垃圾观点，就不仅需要自然语言处理，也需要对于数据的挖掘。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h6 id="情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。"><a href="#情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。" class="headerlink" title="情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。"></a>情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。</h6><h3 id="2-1-问题定义"><a href="#2-1-问题定义" class="headerlink" title="2.1 问题定义"></a>2.1 问题定义</h3><h4 id="2-1-1-观点定义"><a href="#2-1-1-观点定义" class="headerlink" title="2.1.1 观点定义"></a>2.1.1 观点定义</h4><p>将一条 <em>opinion</em> 分为四个部分：（<em>g ,s ,h ,t</em> ）</p><ul><li>g —— target 对象</li><li>s —— sentiment 情感</li><li>h —— holder 评论者</li><li>t —— time 时间</li></ul><p>如果进一步考虑，则可以将观点的对象这一实体分为不同的方面考虑，继而则形成了五元组：（<em>e ,a ,s ,h ,t</em> ）,其中：</p><ul><li>e —— entity 实体</li><li>a —— aspect 方面</li></ul><h4 id="2-1-2-情感分析任务"><a href="#2-1-2-情感分析任务" class="headerlink" title="2.1.2 情感分析任务"></a>2.1.2 情感分析任务</h4><p>主要分为以下几个任务：</p><p>​        情感分析的目的、实体分类和表达的定义、各方面分类和表达的定义、显性方面表达的定义、隐形方面表达的定义、实体模型、观点文献的模型</p><p>总结得到六个任务：</p><p>Task1：提取整体并分类</p><p>Task2：提取方面并分类</p><p>Task3：提取观点持有者并分类</p><p>Task4：提取时间并规范化</p><p>Task5：提取情感并分类</p><p>Task6：观点的五部分 <em>(e ,a ,s ,h ,t  )</em>的综合</p><h4 id="2-2-观点总结"><a href="#2-2-观点总结" class="headerlink" title="2.2 观点总结"></a>2.2 观点总结</h4><p>​        由于我们往往需要获取不只一个用户的观点，而是需要统计大量的评论，这使得我们需要对于它们进行总结，需要兼顾质量和数量。</p><h4 id="2-3-观点的不同类型"><a href="#2-3-观点的不同类型" class="headerlink" title="2.3 观点的不同类型"></a>2.3 观点的不同类型</h4><ul><li><p>一般性和比较性观点</p></li><li><p>明确性和暗示性观点</p></li></ul><h4 id="2-4-主观性和情绪"><a href="#2-4-主观性和情绪" class="headerlink" title="2.4 主观性和情绪"></a>2.4 主观性和情绪</h4><p>主观性评论与客观性评论：</p><ul><li>主观评论往往表现了个人的一些观点和感觉，客观则是包含一些事实信息。</li><li>主观评论可能不包含任何感情，客观语句也可能暗示一些情感或观点。</li></ul><p>情感（emotion）：</p><ul><li>主观性的感觉或想法</li><li>五个情感等级<ol><li>emotional negative </li><li>rational negative</li><li>neutral</li><li>rational positive</li><li>emotional positive</li></ol></li></ul><h4 id="2-5-作者及读者立场"><a href="#2-5-作者及读者立场" class="headerlink" title="2.5 作者及读者立场"></a>2.5 作者及读者立场</h4><p>​        不同层次立场的人看待相同的问题可能会产生不同的乃至相反的想法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统2</title>
    <link href="/2020/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2/"/>
    <url>/2020/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统2——关系数据库系统。</p><a id="more"></a><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h6 id="关系模型是由-E-F-Codd-于-1970-年提出的。"><a href="#关系模型是由-E-F-Codd-于-1970-年提出的。" class="headerlink" title="关系模型是由 E.F.Codd 于 1970 年提出的。"></a>关系模型是由 E.F.Codd 于 1970 年提出的。</h6><h4 id="关系模型的组成要素"><a href="#关系模型的组成要素" class="headerlink" title="关系模型的组成要素"></a>关系模型的组成要素</h4><h5 id="三个组成要素"><a href="#三个组成要素" class="headerlink" title="三个组成要素"></a>三个组成要素</h5><ul><li>关系数据结构<ul><li>建立在<strong>集合代数</strong>的基础上</li></ul></li><li>完整性约束<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li><li>关系运算<ul><li>关系代数 —— 基于集合的运算 —— 基于关系代数设计的数据库语言（ISBL）</li><li>关系演算<ul><li>元组演算 —— 基于逻辑的运算 —— 基于元组演算设计的数据库语言（QUEL）</li><li>域演算 —— 基于示例的运算 —— 基于域演算设计的数据库语言（eg：QBE）</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p><strong>基本概念</strong></p><ul><li><p><strong>关系</strong> —— 表</p><ul><li>数据集合</li><li>属性不可再分（关系第一范式）</li></ul></li><li><p><strong>元组</strong>（记录） —— 行 </p><ul><li>任意两个元组不可重复（集合性质）<ul><li>但是很多产品没有遵守这一性质</li></ul></li></ul></li><li><p><strong>属性</strong>（字段、数据项）—— 列</p><ul><li>同质性：每一列中的分量是同类型的，来自同一个域</li><li>不同的列可能出自同一个域</li></ul></li><li><p><strong>域</strong> —— 列的取值范围</p><ul><li>一组具有相同数据类型的值的集合</li></ul></li><li><p><strong>关系模式</strong> —— 大概相当于表头（并不）</p><p>形式：$R(U,D,DOM,I,F)$</p><p>简记为：$R(U)$，若 $U=\{A_1,A_2,…,A_n\}$，也可写为 $R(A_1,A_2,…,A_n)$，n 称为关系的目（或者度）。</p></li><li><p><strong>关系实例</strong>：关系模式在给定时刻的一个快照。时某一时刻现实世界状态的真实反映。</p></li><li><p><strong>关系数据库模式&amp;关系数据库实例</strong></p></li></ul></li><li><p><strong>补充概念</strong></p><ul><li><p><strong>基数</strong>：集合中元素的个数</p></li><li><p><strong>笛卡尔积</strong>：由n个域形成的所有可能的n元组的集合</p><p>$D_1 \times D_2 \times … \times D_n = \{(d_1,d_2,…,d_n) | d_i \in D_i, i = 1,2,…,n \}$</p><p>笛卡尔积的每一个元素成为一个n-元组。</p></li><li><p><strong>分量</strong>：元组中的每一个值叫做一个分量</p></li></ul></li></ul><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><h5 id="各种码的概念"><a href="#各种码的概念" class="headerlink" title="各种码的概念"></a>各种码的概念</h5><ul><li><p><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以<strong>唯一标识一个元组</strong>的。</p></li><li><p><strong>候选码</strong>：最小的超码，一个关系模式中可能不止一个候选码。</p></li><li><strong>主码</strong>：被选定用来区分不同元组的候选码，一个关系模式只有一个。</li><li><strong>主属性</strong>：主码中的属性。</li><li><strong>外码</strong>：关系模式$R_1$的属性中包含另一个关系模式$R_2$中的主码，这个属性集合被称为参照$R_2$的外码。</li></ul><h5 id="关系数据模型的完整性约束"><a href="#关系数据模型的完整性约束" class="headerlink" title="关系数据模型的完整性约束"></a>关系数据模型的完整性约束</h5><ul><li><strong>实体完整性约束</strong>：主码属性值不能为空值。<ul><li>空值：不知道、不存在或者无意义的值。</li></ul></li><li><strong>参照完整性约束</strong>：如果关系$R_1$的外码$F_k$与关系$R_2$的主码$P_k$相对应，则$R_1$中的每一个元组的$F_k$值要等于$R_2$中某个元组的$P_k$值或者为空值。</li><li><strong>用户定义的完整性约束</strong>：用户针对具体的应用程序定义的完整性约束条件。</li></ul><p>（语义完整性约束和函数依赖？）</p><h5 id="DBMS对于完整性的支持"><a href="#DBMS对于完整性的支持" class="headerlink" title="DBMS对于完整性的支持"></a>DBMS对于完整性的支持</h5><ul><li>实体完整性&amp;参照完整性是由DBMS系统字段支持的</li><li>DBMS系统通常会提供以下机制：<ul><li>使得用户可以自行定义有关的完整性约束条件。</li><li>在发生更新时自动检验。</li></ul></li></ul><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><h5 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h5><h6 id="关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。"><a href="#关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。" class="headerlink" title="关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。"></a>关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。</h6><p><strong>关系代数运算</strong></p><ul><li>六种基本运算：选择、投影、并、差、笛卡尔积、重命名。</li><li>其他运算：交、连接、除。（可用基本运算组合定义）</li></ul><p><strong>相容性</strong>：关系 R 与关系 S 存在相容性，当且仅当：</p><ol><li>关系 R 与关系 S 的属性数目相同。</li><li>R 中与 S 中相对应位置的属性的域相同。</li></ol><h6 id="并、差、交运算需满足相容性"><a href="#并、差、交运算需满足相容性" class="headerlink" title="并、差、交运算需满足相容性"></a><em>并、差、交运算需满足相容性</em></h6><p><strong>关系代数基本运算</strong></p><ul><li><strong>并</strong>： $R\cup S = \{t | t \in R \wedge t\in S\}$，其中 $t$ 是元组。</li><li><strong>差</strong>：$R-S = \{t \in R \wedge t\notin S\}$</li><li><strong>笛卡尔积（积）</strong>：$R \times S = \{<a_1,a_2,...,a_n,b_1,...,b_m> | <a_1,a_2,...,a_n>\in R \wedge <b_1,...,b_m> \in S \}$</b_1,...,b_m></a_1,a_2,...,a_n></a_1,a_2,...,a_n,b_1,...,b_m></li><li><strong>选择</strong>：$\sigma_{con}(R)=\{t | t\in R\wedge con(t)\}$<ul><li>$con$为选择谓词，运算符优先次序为：$括号; \theta; \lnot ; \wedge; \vee$ </li></ul></li><li><strong>投影</strong>：$\Pi_{A_1,A_2,…A_k}(R) = \{<t[A_1],t[A_2],...,t[A_k]> | t\in R\}$<ul><li>注意去除重复元组</li></ul></t[A_1],t[A_2],...,t[A_k]></li><li><strong>更名</strong>：$\rho_S (R)$ 或者 $\rho_{S(A_1,…,A_n)}(R)$</li></ul><p><strong>附加运算</strong></p><h6 id="附加运算不增加关系代数的表达能力，但是可以简化常用查询。"><a href="#附加运算不增加关系代数的表达能力，但是可以简化常用查询。" class="headerlink" title="附加运算不增加关系代数的表达能力，但是可以简化常用查询。"></a>附加运算不增加关系代数的表达能力，但是可以简化常用查询。</h6><ul><li><strong>交</strong>：$R \cap  S = \{t |t\in R and t \in S\}$</li><li><strong>连接</strong><ul><li>$\theta$ <strong>连接</strong>：大概是有连接条件的连接</li><li><strong>等值连接</strong>：$\theta$ 为等号的$\theta$ 连接</li><li><strong>自然连接</strong>（$\bowtie$）：要求进行笛卡尔积的两个关系在所有相同属性上的值一致</li></ul></li><li><strong>赋值</strong>：只能赋给临时关系变量，不能增加关系运算的表达能力</li><li><strong>外连接</strong>：（左外连接&amp;右外连接&amp;全外连接）左外是以左边为准，没法匹配的用null填充右边属性。</li><li><strong>除</strong>：$R \div S = \{t | t \in \Pi_z(R) \wedge \forall u \in S (tu \in R) \}$</li></ul><p><strong>其他扩展运算</strong></p><h6 id="可以实现不能有基本的关系代数运算来表达的查询"><a href="#可以实现不能有基本的关系代数运算来表达的查询" class="headerlink" title="可以实现不能有基本的关系代数运算来表达的查询"></a>可以实现不能有基本的关系代数运算来表达的查询</h6><ul><li>广义投影：在投影中使用算术运算和字符</li><li>聚集</li></ul><h5 id="关系演算——元组演算"><a href="#关系演算——元组演算" class="headerlink" title="关系演算——元组演算"></a>关系演算——元组演算</h5><h6 id="非过程化的查询语言，只需要描述所需信息而不需要给出获取过程"><a href="#非过程化的查询语言，只需要描述所需信息而不需要给出获取过程" class="headerlink" title="非过程化的查询语言，只需要描述所需信息而不需要给出获取过程"></a>非过程化的查询语言，只需要描述所需信息而不需要给出获取过程</h6><ul><li><p>表达式：$\{t | P(T)\}$</p><ul><li>所有使得公式P为真的元组t的集合</li></ul></li><li><p>公式P由原子公式构成</p><ul><li>$s \in R; s[x] \Theta u[y]; s[x] \Theta C.$</li></ul></li></ul><h5 id="关系演算——域演算"><a href="#关系演算——域演算" class="headerlink" title="关系演算——域演算"></a>关系演算——域演算</h5><h6 id="使用从属性域中取值的域变量，而不是整个元组的值"><a href="#使用从属性域中取值的域变量，而不是整个元组的值" class="headerlink" title="使用从属性域中取值的域变量，而不是整个元组的值"></a>使用从属性域中取值的域变量，而不是整个元组的值</h6><ul><li>形式化定义：$\{<x_1,...,x_n>|P(x_1,…,x_n)\}$<ul><li>其中$x_1,…,x_n$分别是域变量</li><li>P由原子公式构成</li><li>查询结果时是有包含$<x_1,...,x_n>$且使$P(x_1,…,x_n)$为真的元组</x_1,...,x_n></li></ul></x_1,...,x_n></li></ul><h5 id="关系运算的安全性"><a href="#关系运算的安全性" class="headerlink" title="关系运算的安全性"></a>关系运算的安全性</h5><ul><li>安全关系运算系统：如果一个关系运算系统不产生不限关系和无穷验证则是安全的</li><li>关系代数系统是安全的</li><li>元组演算和域演算是不安全的<ul><li>引入元组关系公式的域的概念，对关系演算进行限制</li></ul></li></ul><h5 id="三者等价性"><a href="#三者等价性" class="headerlink" title="三者等价性"></a>三者等价性</h5><p>下述三者等价：</p><ul><li>基本关系代数</li><li>限制在安全范围内的元组关系演算</li><li>限制在安全范围内的域关系演算</li></ul><h6 id="本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）"><a href="#本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）" class="headerlink" title="本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）"></a>本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统1</title>
    <link href="/2020/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1/"/>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统1——基本知识与关系模型。</p><p>​        参考了中国人民大学的 Mooc 和战神的 Spoc 以及教材。</p><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h4 id="一些名词："><a href="#一些名词：" class="headerlink" title="一些名词："></a><strong>一些名词：</strong></h4><ul><li><p>数据（Data）:描述事物的符号记录。数据与其语义不可分。</p></li><li><p>数据库 （DB）：长期储存在计算机内的、有组织的、可共享的、相互关联的数据的集合。</p></li><li><p>数据库管理系统 （DBMS）：管理数据库的软件系统。</p></li><li><p>SQL（结构化查询语言）：用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。</p></li><li><p>数据库应用程序 （DBAP）</p></li><li><p>数据库系统（DBS）：指在计算机系统中引入数据库后构成的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户构成。</p></li></ul><h4 id="数据库管理技术发展过程"><a href="#数据库管理技术发展过程" class="headerlink" title="数据库管理技术发展过程"></a>数据库管理技术发展过程</h4><p>​    三个阶段：人工管理阶段 $\rightarrow$ 文件系统阶段 $\rightarrow$ 数据库系统阶段</p><p>​    阶段对比如下表（来自人大的Mooc）</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1.assets/image-20200304164606749.png" srcset="/img/loading.gif" alt="image-20200304164606749"></p><h4 id="数据库管理系统功能"><a href="#数据库管理系统功能" class="headerlink" title="数据库管理系统功能"></a>数据库管理系统功能</h4><h5 id="从用户角度考虑"><a href="#从用户角度考虑" class="headerlink" title="从用户角度考虑"></a>从用户角度考虑</h5><ul><li>数据库定义：提供 <strong>数据定义语言（DDL）</strong> 以定义数据格式。</li><li>数据库操纵：提供 <strong>数据操纵语言（DML）</strong>进行数据的<strong>增、删、改、(查)</strong> 操作。</li><li>数据库控制：提供 <strong>数据控制语言（DCL）</strong> 让管理员对于数据的使用进行控制。</li><li>数据库维护：转储、恢复、重组、性能检测、分析等。</li></ul><p><em>DDL、DML、DCL 联合起来就是 SQL语言。（不过这句话我有点疑惑…）</em></p><h5 id="从系统实现角度考虑"><a href="#从系统实现角度考虑" class="headerlink" title="从系统实现角度考虑"></a>从系统实现角度考虑</h5><ul><li>语言编译器：将用数据库语言书写的内容翻译成DBMS的可执行命令。</li><li>查询优化（执行引擎）与查询实现（基本命令的不同执行算法）</li><li>数据存取索引：提供数据在磁盘、磁带等上的高效存取手段。</li><li>通信控制：提供网络环境下的数据库操作与数据传输手段。</li><li>事务管理：提供高可靠性并避免并发操作错误的手段。</li><li>故障恢复：是数据库自动恢复到故障发生前的正常状态的手段。</li><li>安全性控制：提供合法性检验，避免非授权用户非法访问的手段。</li><li>完整性控制：提供数据集数据操作正确性检查的手段。</li><li>应用程序接口（API）：提供应用程序使用DBMS特定功能的手段。</li><li>数据库数据装载、重组等实用程序</li><li>数据库性能分析</li></ul><h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><h4 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h4><p>三层抽象：（不同的 Mooc 称呼不太一样233）</p><ul><li>视图层（外部层次）</li><li>逻辑层（全局层次）</li><li>物理层（内部层次）</li></ul><h4 id="模式与实例"><a href="#模式与实例" class="headerlink" title="模式与实例"></a>模式与实例</h4><p>​    模式——对于数据可逻辑结构和特征的描述、不涉及具体的值且相对稳定。</p><p>​    实例——模式的具体值，是数据库在将某一时刻的状态、随数据库的数据更新而改变。</p><h4 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h4><ol><li>逻辑独立性：用户应用程序与数据库的逻辑结构相互独立。</li><li>物理独立性：用户的应用程序与数据库中数据的的物理存储相互独立。</li></ol><p><em>数据独立性是由DBMS的两层映像保证的。</em></p><h4 id="三级模式与两层映像"><a href="#三级模式与两层映像" class="headerlink" title="三级模式与两层映像"></a>三级模式与两层映像</h4><h5 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a><strong>三级模式</strong></h5><p>​    <em>三级模式与之前的三层抽象相对应</em></p><ul><li>外模式（子模式）—— 局部角度</li><li>逻辑模式 —— 全局角度</li><li>内模式（物理模式、存储模式）</li></ul><h5 id="两层映像"><a href="#两层映像" class="headerlink" title="两层映像"></a><strong>两层映像</strong></h5><p>​    <em>三个层次的联系和转换，由DBMS内部提供</em></p><ul><li>外模式 - 逻辑模式（E-C）映像<ul><li>映像定义通常包含在各外模式描述中。</li><li>保证了数据的逻辑独立性：在逻辑模式发生改变时，数据库管理员可以通过修改E-C映像是的外模式保持不变，从而使得依据外模式编写的应用程序无需修改。</li></ul></li><li>逻辑模式 - 内模式 （C-I）映像<ul><li>映像定义通常包含各逻辑模式描述中。</li><li>保证了数据的物理独立性：物理存储模式发生变化时，通过修改映像使得逻辑模式不变，外模式不变，应用程序不变。</li></ul></li></ul><p>作用：</p><ul><li>保证了应用程序的稳定性，减少了应用程序的维护和修改。</li><li>使得数据定义和描述从应用程序中分离开。</li><li>数据的存取由DBMS管理，简化了应用程序的编制。</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h6 id="这部分主要参考了人大的mooc"><a href="#这部分主要参考了人大的mooc" class="headerlink" title="这部分主要参考了人大的mooc"></a>这部分主要参考了人大的mooc</h6><h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><ol><li><p>概念模型（信息模型）—— 按用户观点考虑、用于数据库设计</p><ul><li>eg：实体—联系模型（E-R模型）</li></ul></li><li>逻辑模型和物理模型<ol><li>逻辑模型 —— 按照计算机系统的观点考虑、用于DBMS的实现<ul><li>网状模型、层次模型</li><li>关系模型</li><li>面向对象（O-O）数据模型、对象关系（O-R）数据模型</li><li>半结构化数据模型</li></ul></li><li>物理模型 —— 对于数据最底层的抽象、描述数据在系统内的表示和存取方法。</li></ol></li></ol><h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><ul><li>数据结构 —— 描述系统的静态特性</li><li>数据操作 —— 描述系统的动态特性</li><li>完整性约束</li></ul><h4 id="层次模型、网状模型与关系模型"><a href="#层次模型、网状模型与关系模型" class="headerlink" title="层次模型、网状模型与关系模型"></a>层次模型、网状模型与关系模型</h4><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>满足以下两个条件的基本层次联系的集合为<strong>层次模型</strong></p><ul><li>有且只有一个节点没有父亲节点——这个节点叫做根节点</li><li>根节点以外的节点有且只有一个父亲节点</li></ul><h6 id="树状哒"><a href="#树状哒" class="headerlink" title="树状哒"></a>树状哒</h6><p><strong>数据结构</strong>——满足下列条件的树</p><ul><li>每个节点代表一个实体</li><li>边表示对象之间的联系</li></ul><p><strong>特点</strong></p><ul><li>只能处理一对多的实体联系（父节点唯一）</li><li>任何记录值都只有按路径查看时才显示全部意义</li><li>没有一个子女记录纸可以推理父亲记录值单独存在</li></ul><p><strong>层次模型的完整性约束</strong></p><ul><li>无相应的父亲节点值就不能插入子女节点值</li><li>删除父亲节点值时，子女节点值也要删除</li><li>更新时，应更新所有相应记录，以保证数据一致性</li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：简单、（对于一对多而言）描述自然直观、易于理解、完整性支持良好</p></li><li><p>缺点：多对多联系表示不自然，插入删除限制多，查询子女节点必须通过父亲节点，面向过程</p></li></ul><h6 id="eg：IMS数据库管理系统（1968）"><a href="#eg：IMS数据库管理系统（1968）" class="headerlink" title="eg：IMS数据库管理系统（1968）"></a>eg：IMS数据库管理系统（1968）</h6><h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p><strong>数据结构</strong>——满足下列条件的图</p><ul><li>每个节点是一个对象记录</li><li>边表示对象之间的联系</li><li>允许多个节点无父亲节点</li><li>允许节点有多个父亲节点</li><li>允许两个节点之间有多种联系</li></ul><h6 id="图状哒"><a href="#图状哒" class="headerlink" title="图状哒"></a>图状哒</h6><p><strong>完整性约束</strong></p><ul><li>允许插入父亲节点值未确定的子女节点值</li><li>允许只删除父亲节点值</li><li>一些具体系统提供了一些完整性约束</li></ul><p><strong>优缺点</strong></p><ul><li>优点：更加直观，性能良好、存取效率高</li><li>缺点：结构复杂，不利于最终用户掌握；DDL、DML语言复杂，不易于用户使用；面型过程</li></ul><h6 id="eg：最早的网状数据库管理系统IDS（1964）"><a href="#eg：最早的网状数据库管理系统IDS（1964）" class="headerlink" title="eg：最早的网状数据库管理系统IDS（1964）"></a>eg：最早的网状数据库管理系统IDS（1964）</h6><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据——信息载体</li><li><p>数据库——数据集合</p></li><li><p>数据库管理系统——软件系统</p></li><li>数据库系统</li></ul><h6 id="本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。"><a href="#本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。" class="headerlink" title="本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。"></a>本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（3）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章-伪随机置换（分组加密）的实际构建"><a href="#第五章-伪随机置换（分组加密）的实际构建" class="headerlink" title="第五章 伪随机置换（分组加密）的实际构建"></a>第五章 伪随机置换（分组加密）的实际构建</h2><h6 id="密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。"><a href="#密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。" class="headerlink" title="密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。"></a>密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。</h6><h3 id="5-1-代替——置换网络"><a href="#5-1-代替——置换网络" class="headerlink" title="5.1 代替——置换网络"></a>5.1 代替——置换网络</h3><p><strong>S盒</strong>（替换盒）：对称密钥加密算法执行替换计算的基本结构。在块密码中，通常被用于模糊密钥与密文之间的关系（香农的混淆理论）</p><h6 id="通常，S-Box接受特定数量的输入比特-m-，并将其转换为特定数量的输出比特-n-，其中-n-不一定等于-m-。一个-m-n-的S-Box可以通过包含-2-m-条目，每条目-n-比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。"><a href="#通常，S-Box接受特定数量的输入比特-m-，并将其转换为特定数量的输出比特-n-，其中-n-不一定等于-m-。一个-m-n-的S-Box可以通过包含-2-m-条目，每条目-n-比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。" class="headerlink" title="通常，S-Box接受特定数量的输入比特$m$，并将其转换为特定数量的输出比特$n$，其中$n$不一定等于$m$。一个$m*n$的S-Box可以通过包含$2^m$条目，每条目$n$比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。"></a>通常，S-Box接受特定数量的输入比特$m$，并将其转换为特定数量的输出比特$n$，其中$n$不一定等于$m$。一个$m*n$的S-Box可以通过包含$2^m$条目，每条目$n$比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。</h6><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140146509.png" srcset="/img/loading.gif" alt="image-20200302140146509"></p><p><strong>P盒</strong>（置换盒）： 是一个透过置换和转置[替换盒（S-boxes）输入进行位元洗牌的方法，在转置的过程中保持一定程度的<a href="https://zh.wikipedia.org/wiki/混淆與擴散" target="_blank" rel="noopener">扩散</a>。 </p><p>置换盒通常分为三类：</p><ul><li>压缩性的——输出位元数比输入少</li><li>扩张性的——输出位元数比输入多</li><li>平直性的——输出位元数等于输入位元数</li></ul><p>其中只有平直性的置换盒是可逆的。</p><p><strong>代替置换网络（SP）</strong>：</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140221062.png" srcset="/img/loading.gif" alt="image-20200302140221062"></p><p><strong>设计原则</strong>：</p><ul><li>S盒的可逆性：在代替置换网络中，S盒必须是可逆的（即必须是单射和满射函数），否则分组函数不能成为一个置换</li><li>雪崩效应：任何分组密码的一个重要特性就是输入的微小改变必然会导致输出的巨大改变，否则两个相似输入所生成的分组密码看起来就不是独立的了。因此，输入的单个比特的变化会影响每一个比特。<ul><li>S盒的设计要使得改变S盒输入的单个比特就能改变S盒输出的至少两个比特</li><li>混合置换的设计要使得任何给定的S盒的输出比特都被传递到下一轮中不同的S盒中</li></ul></li></ul><p><strong>代替置换网络的安全性</strong>：</p><p><strong>对轮数较少的代替转换网络的攻击</strong>：</p><p><strong>攻击三轮代替-置换网络</strong>：</p><h3 id="5-2-Feistel网络"><a href="#5-2-Feistel网络" class="headerlink" title="5.2 Feistel网络"></a>5.2 Feistel网络</h3><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140312519.png" srcset="/img/loading.gif" alt="image-20200302140312519"></p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140333394.png" srcset="/img/loading.gif" alt="image-20200302140333394"></p><h3 id="5-3-DES——数据加密标准"><a href="#5-3-DES——数据加密标准" class="headerlink" title="5.3 DES——数据加密标准"></a>5.3 DES——数据加密标准</h3><h3 id="5-4-增加分组密码的密钥长度"><a href="#5-4-增加分组密码的密钥长度" class="headerlink" title="5.4 增加分组密码的密钥长度"></a>5.4 增加分组密码的密钥长度</h3><h3 id="5-5-AES——高级加密标准"><a href="#5-5-AES——高级加密标准" class="headerlink" title="5.5 AES——高级加密标准"></a>5.5 AES——高级加密标准</h3><h3 id="5-6-差分密码盒线性密码分析简介"><a href="#5-6-差分密码盒线性密码分析简介" class="headerlink" title="5.6 差分密码盒线性密码分析简介"></a>5.6 差分密码盒线性密码分析简介</h3><h2 id="第六章-伪随机对象的理论构造"><a href="#第六章-伪随机对象的理论构造" class="headerlink" title="第六章 伪随机对象的理论构造"></a>第六章 伪随机对象的理论构造</h2><h3 id="6-1-单向函数"><a href="#6-1-单向函数" class="headerlink" title="6.1 单向函数"></a>6.1 单向函数</h3><h5 id="单向函数的定义："><a href="#单向函数的定义：" class="headerlink" title="单向函数的定义："></a>单向函数的定义：</h5><ul><li>令$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$为一个函数，$A$为任意算法，$n$为任意安全参数值：<ul><li>求逆实验$Invert_{A.f}(n)$<ul><li>选择输入$x\leftarrow\{0,1\}^n$，计算$y:=f(x)$</li><li>$1^n$和$y$值作为$A$的输入，输出为$x’$</li><li>如果$f(x’)=y$，那么定义该实验输出为1，否则为0</li></ul></li></ul></li><li><strong>定义</strong>：如果一个函数$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$满足以下两个条件，那么它是单向函数：<ul><li>（易于计算）存在多项式时间算法$M_f$来计算$f$,即对于所有的$x$，有$M_f(x)$</li><li>（反向求逆十分困难）对任意概率多项式时间算法$A$，存在一个可忽略函数$negl$，满足：$Pr[Invert_{A,f}(n)=1]\leqslant negl(n)$<ul><li>也可表示为：$Pr_{x\leftarrow\{0,1\}^n}[A(f(x))∈f^{-1}(f(x))] \leqslant negl(n) $</li></ul></li></ul></li></ul><h5 id="单向置换："><a href="#单向置换：" class="headerlink" title="单向置换："></a>单向置换：</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（2）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章-对称密钥加密及为随机性"><a href="#第三章-对称密钥加密及为随机性" class="headerlink" title="第三章 对称密钥加密及为随机性"></a>第三章 对称密钥加密及为随机性</h2><h3 id="3-1密码学的计算方法"><a href="#3-1密码学的计算方法" class="headerlink" title="3.1密码学的计算方法"></a>3.1密码学的计算方法</h3><h4 id="信息理论安全与计算安全"><a href="#信息理论安全与计算安全" class="headerlink" title="信息理论安全与计算安全"></a>信息理论安全与计算安全</h4><ul><li>信息理论安全：完善保密加密</li><li>计算安全：使用具体方法和渐进方法来定义：<ul><li>具体方法：如果每个运行时间最多为$t$的敌手以最多为$\varepsilon$的概率成功公婆该方案，则称这个方案为$(t,\varepsilon)$安全</li><li>渐进方法：如果每个PPT（多项式时间）敌手以可忽略的概率成功攻破一个方案，那么该方案是安全的<ul><li>注：在任何加密方案中，密钥空间必须足够大，以至于敌手不能变量，或者说，密钥空间的时间规模必须为安全参数的超多项式</li></ul></li></ul></li></ul><h4 id="有效的算法与可忽略的成功概率"><a href="#有效的算法与可忽略的成功概率" class="headerlink" title="有效的算法与可忽略的成功概率"></a>有效的算法与可忽略的成功概率</h4><ul><li><strong>有效计算</strong>：指能够在“概率多项式时间”（PPT）内执行的计算</li><li><strong>可忽略的成功概率</strong>：如果对于每一个多项式$p(.)$，存在一个$N$，使得所有的整数$n&gt;N$，都满足$f(n)&lt;1/p(n)$，则函数$f$是可忽略的</li></ul><h4 id="如何证明某个密码构造是安全的"><a href="#如何证明某个密码构造是安全的" class="headerlink" title="如何证明某个密码构造是安全的"></a>如何证明某个密码构造是安全的</h4><ol><li>指定PPT敌手$A$攻击，并将成功的概率表示为$\varepsilon(n)$</li><li>构造一个叫做”规约“的有效算法$A~’$（区分器？）,该算法将敌手$A$作为子程序来使用，试图解决难题$X$。<img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89.assets/image-20200302140115640.png" srcset="/img/loading.gif" alt="image-20200302140115640"></li><li>如果能成功攻破，那么说明该区分器可以区分这个加密算法所使用的伪随机生成器</li><li>但是根据伪随机生成器的定义，不可被区分</li><li>所以矛盾，证明该算法安全</li></ol><h3 id="3-2-定义计算安全的加密"><a href="#3-2-定义计算安全的加密" class="headerlink" title="3.2 定义计算安全的加密"></a>3.2 定义计算安全的加密</h3><h4 id="窃听者存在情况下的不可区分性"><a href="#窃听者存在情况下的不可区分性" class="headerlink" title="窃听者存在情况下的不可区分性"></a>窃听者存在情况下的不可区分性</h4><p>​    窃听者不可区分实验$PrivK^{eav}_{A,\Pi}(n)$:</p><ul><li>给定输入$1^n$给敌手$A$，$A$输出一对长度相等的消息$m_0$,$m_1$。</li><li>运行$Gen(1^n)$生成以个密钥k，选择一个随机比特$b$，$b∈\{0,1\}$。计算出密文$c=Enc_k(m_b)$，并且给$A$。把$c$叫做挑战密文。</li><li>$A$输出一个比特$b’$</li><li>如果$b=b’$输出1，反之输出0.</li></ul><h5 id="定义：如果对于所有的概率多项式事件敌手-A-存在一个可忽略函数-negl-使得：-Pr-PrivK-eav-A-Pi-lt-1-2-negl-n-则一个对称密钥加密方案-Pi-Gen-Enc-Dec-具备在窃听者存在的情况下不可区分的加密。"><a href="#定义：如果对于所有的概率多项式事件敌手-A-存在一个可忽略函数-negl-使得：-Pr-PrivK-eav-A-Pi-lt-1-2-negl-n-则一个对称密钥加密方案-Pi-Gen-Enc-Dec-具备在窃听者存在的情况下不可区分的加密。" class="headerlink" title="定义：如果对于所有的概率多项式事件敌手$A$,存在一个可忽略函数$negl$使得：$Pr[PrivK^{eav}_{A,\Pi}&lt;= 1/2 +negl(n)$,则一个对称密钥加密方案$\Pi=(Gen,Enc,Dec)$具备在窃听者存在的情况下不可区分的加密。"></a>定义：如果对于所有的概率多项式事件敌手$A$,存在一个可忽略函数$negl$使得：$Pr[PrivK^{eav}_{A,\Pi}&lt;= 1/2 +negl(n)$,则一个对称密钥加密方案$\Pi=(Gen,Enc,Dec)$具备在窃听者存在的情况下不可区分的加密。</h5><h5 id="等价公式：-Pr-output-PrivK-eav-A-Pi-n-0-1-Pr-output-PrivK-eav-A-Pi-n-1-1-lt-negl-n"><a href="#等价公式：-Pr-output-PrivK-eav-A-Pi-n-0-1-Pr-output-PrivK-eav-A-Pi-n-1-1-lt-negl-n" class="headerlink" title="等价公式：$|Pr[output(PrivK^{eav}_{A,\Pi}(n,0))=1]-Pr[output(PrivK^{eav}_{A,\Pi}(n,1))=1]| &lt;= negl(n)$"></a>等价公式：$|Pr[output(PrivK^{eav}_{A,\Pi}(n,0))=1]-Pr[output(PrivK^{eav}_{A,\Pi}(n,1))=1]| &lt;= negl(n)$</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（1）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h1><h2 id="1-2-对称密钥加密"><a href="#1-2-对称密钥加密" class="headerlink" title="1.2 对称密钥加密"></a>1.2 对称密钥加密</h2><p>对称密钥（秘密密钥）：双方共享密码信息（密钥）</p><ul><li>消息本身称为明文</li><li>加密后的消息称为密文</li></ul><p>对称密钥加密方案包含的三个算法：密钥产生、加密、解密</p><ul><li><strong>密钥产生算法（Gen）</strong>：概率算法，根据方案定义的某种分布选择并输出一个密钥<em>k</em></li><li><strong>加密算法（Enc）</strong>：输入密钥<em>k</em>和明文<em>m</em>，输出密文<em>c</em>。记为$Enc_k(m)$</li><li><strong>解密算法（Dec）</strong>：输入密钥<em>k</em>和密文<em>c</em>，输出明文<em>m</em>。记为$Dec_k(c)$</li><li><strong>密钥空间（<em>K</em>）</strong>：密钥产生函数输出的所有可能密钥称为密钥空间</li><li><strong>明文（消息）空间（<em>M</em>）</strong>：所有被加密算法支持的消息的集合</li><li>一个加密方案可由明确三个算法（Gen，Enc，Dec）和明文空间<em>M</em>来完全定义</li></ul><p><strong>攻击场景</strong></p><ul><li><p><strong>唯密文攻击</strong>：仅已知密文</p></li><li><p><strong>已知明文攻击</strong>：已知一个或多个使用相同密钥加密的明文/密文对</p></li><li><p><strong>选择明文攻击</strong>：可以选择明文得到其对应密文</p></li><li><p><strong>选择密文攻击</strong>：可以选择密文得到其对应明文</p></li></ul><h2 id="1-3-古典加密术及其密码分析"><a href="#1-3-古典加密术及其密码分析" class="headerlink" title="1.3 古典加密术及其密码分析"></a>1.3 古典加密术及其密码分析</h2><p><strong>凯撒加密</strong>：移位3字母</p><p><strong>移位加密</strong>:密钥<em>k</em>∈(0,25)，加密时字母移动<em>k</em>个位置</p><p><em>密钥空间充分性原则：任何安全的加密方案必须拥有一个能够抵御穷举搜索的密钥空间</em></p><p><strong>单字母替换（substitution）</strong>：一一映射</p><p><strong>多字母移位加密（Vigenere）</strong>：如图</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/1.png" srcset="/img/loading.gif" alt></p><h1 id="第二章-完善保密加密"><a href="#第二章-完善保密加密" class="headerlink" title="第二章 完善保密加密"></a>第二章 完善保密加密</h1><h2 id="2-1-完善保密加密"><a href="#2-1-完善保密加密" class="headerlink" title="2.1 完善保密加密"></a>2.1 完善保密加密</h2><p><strong>完善保密加密：</strong></p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302123938147.png" srcset="/img/loading.gif" alt="image-20200302123938147"></p><p><strong>完美不可区分性：</strong>密文不包含任何明文信息（密文空间的概率分布独立于明文？）</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135646380.png" srcset="/img/loading.gif" alt="image-20200302135646380"></p><p><strong>敌手不可区分性：</strong>敌手不能区分密文时来自哪个明文的加密</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135906974.png" srcset="/img/loading.gif" alt="image-20200302135906974"></p><p>其中：</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135937398.png" srcset="/img/loading.gif" alt="image-20200302135937398"></p><h2 id="2-2-一次一密（Vernam加密）"><a href="#2-2-一次一密（Vernam加密）" class="headerlink" title="2.2 一次一密（Vernam加密）"></a>2.2 一次一密（Vernam加密）</h2><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135958699.png" srcset="/img/loading.gif" alt="image-20200302135958699"></p><h2 id="2-3-完善保密加密局限"><a href="#2-3-完善保密加密局限" class="headerlink" title="2.3 完善保密加密局限"></a>2.3 完善保密加密局限</h2><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302140015396.png" srcset="/img/loading.gif" alt="image-20200302140015396"></p><h2 id="2-4-香农定理"><a href="#2-4-香农定理" class="headerlink" title="2.4 香农定理"></a>2.4 香农定理</h2><p> 定理：设加密方案 （Gen,Enc,Dec）的明文空间为<em>M</em>，且|<em>K</em>|=|<em>M</em>|=|<em>C</em>|，则当且仅当下列条件成立时，此方案是完善保密加密：</p><ul><li>由Gen产生的任意密钥<em>k</em>∈<em>K</em>的概率都是1/|<em>K</em>|。</li><li>对任意明文<em>m</em>∈<em>M</em>和任意密文<em>c</em>∈<em>C</em>，只存在唯一的密钥<em>k</em>∈<em>K</em>使得$Enc_k(m)$输出<em>c</em>。</li></ul><script type="math/tex; mode=display">a+b=c</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络1</title>
    <link href="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
    <url>/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络 1"></a>计算机网络 1</h1><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><p><strong>计算机网络的定义：</strong>计算机网络是<strong>互联</strong>的，<strong>自治</strong>的计算机集合</p><ul><li>自治：无主从关系</li><li>互联：互联互通</li><li>计算机网络是一种<strong>通信网络</strong></li></ul><p>主机通过<strong>交换网络</strong>互连</p><p><strong>ISP</strong>：因特网服务提供商</p><p><strong>网络协议（协议）</strong>：是为了进行网络中数据交换而建立的规则、标准或约定。它规定了通信实体之间所交换的消息的<strong>格式</strong>、<strong>意义</strong>、<strong>顺序</strong>以及针对收到信息或发生的事件所采取的动作。</p><ul><li>三要素：<ul><li>语法：<em>数据与控制信息的结构或格式；信号电平。</em></li><li>语义：<em>要放发出何种控制信息、完成何种动作、做出何种响应；差错控制。</em></li><li>时序：<em>事件顺序；速度匹配。</em></li></ul></li><li>协议规范了网络中所有信息的发送和接收过程</li></ul><p><strong>计算机网络结构</strong>：</p><ul><li>网络边缘<ul><li>主机（端系统）</li><li>客户/服务器（C/S）应用模型</li><li>对等（P2P）应用模型<ul><li><em>在对等者之间分配任务和工作负载的分布式应用架构</em></li><li><em>网络的参与者共享他们所拥有的一部分硬件资源、这些资源通过网络提供服务和内容，可被其他节点直接访问二无需经过中间实体。</em></li><li><em>既是Server，也是Client。</em></li></ul></li></ul></li><li>接入网络，物理介质:<br>- </li><li>网络核心（核心网络）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
