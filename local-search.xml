<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库系统3</title>
    <link href="/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3/"/>
    <url>/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统3——结构化查询语言SQL。</p><a id="more"></a><h2 id="SQL查询语言概览"><a href="#SQL查询语言概览" class="headerlink" title="SQL查询语言概览"></a>SQL查询语言概览</h2><h5 id="SQL语言的几个部分"><a href="#SQL语言的几个部分" class="headerlink" title="SQL语言的几个部分"></a>SQL语言的几个部分</h5><p>数据定义语言（DDL）：提供定义关系模式、删除关系以及修改关系模式的命令</p><p>数据操纵语言（DML）：提供从数据中查询信息、插入删除修改元组的能力</p><p>完整性：SQL DDL 包括定义完整性的约束命令</p><p>视图定义：SQL DDL 包括定义视图的命令</p><p>事务控制：定义事务的开始和结束</p><p>嵌入式SQL和动态SQL：如何将SQL陷入到通用编程语言</p><p>授权：SQL DDL 包括定义访问权限的命令</p><p>SQL语言特点：</p><ul><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>简便易学易用</li></ul><h2 id="SQL数据定义"><a href="#SQL数据定义" class="headerlink" title="SQL数据定义"></a>SQL数据定义</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215355571.png" srcset="/img/loading.gif" alt="image-20200629215355571"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215530535.png" srcset="/img/loading.gif" alt="image-20200629215530535"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215715100.png" srcset="/img/loading.gif" alt="image-20200629215715100"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215841656.png" srcset="/img/loading.gif" alt="image-20200629215841656"></p><h2 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h2><p>单表查询</p><ul><li>最简单、仅涉及一个表</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629221054876.png" srcset="/img/loading.gif" alt="image-20200629221054876" style="zoom: 67%;"></li></ul><p>连接查询</p><ul><li>同时涉及到多个表的查询</li><li>连接条件</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629221144057.png" srcset="/img/loading.gif" alt="image-20200629221144057" style="zoom:67%;"></li></ul><p>嵌套子查询</p><ul><li>将一个查询块嵌套在另一个查询块的where、from、having语句条件中的查询</li><li>由里向外处理</li><li>子查询不能使用order by</li><li>有些嵌套查询可以用连接运算替代</li></ul><p>集合查询</p><ul><li>并（union）、交（intersect）、差（except）</li><li>参加集合操作的各结果表列数和对应数据类型必须相同</li></ul><h2 id="SQL数据库的修改"><a href="#SQL数据库的修改" class="headerlink" title="SQL数据库的修改"></a>SQL数据库的修改</h2><h5 id="SQL语言数据更新机制"><a href="#SQL语言数据更新机制" class="headerlink" title="SQL语言数据更新机制"></a>SQL语言数据更新机制</h5><ul><li>DBMS在执行插入、修改及删除语句时会检查元组是否会破坏表上已定义的完整性规则</li></ul><h2 id="SQL事务"><a href="#SQL事务" class="headerlink" title="SQL事务"></a>SQL事务</h2><p>事务是由查询或更新语句序列组成的</p><ul><li>Commit：提交当前事务（永久保存）</li><li>Rollback：回滚当前事务（撤销该事务中所有SQL语句对数据库的更新）</li><li>事务具有原子性</li><li>定义语句：begin atomic … end</li></ul><h2 id="SQL触发器"><a href="#SQL触发器" class="headerlink" title="SQL触发器"></a>SQL触发器</h2><p>触发器（trigger）</p><ul><li>一条语句，对数据修改时自动执行</li><li>设置触发器机制的两个要求：<ul><li>指明执行条件</li><li>指明触发器动作</li></ul></li><li>一旦把一个触发器输入数据库，只要指定的事件发生，相应条件满足，数据库系统就有责任执行它</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629223204596.png" srcset="/img/loading.gif" alt="image-20200629223204596" style="zoom: 50%;"></li></ul><h2 id="SQL数据库授权机制"><a href="#SQL数据库授权机制" class="headerlink" title="SQL数据库授权机制"></a>SQL数据库授权机制</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629224049807.png" srcset="/img/loading.gif" alt="image-20200629224049807" style="zoom:67%;"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629224100841.png" srcset="/img/loading.gif" alt="image-20200629224100841" style="zoom:67%;"></p><h2 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h2><p>嵌入式SQL</p><ul><li>可以在程序设计语言中使用的SQL语言</li><li>这种程序设计语言被称为宿主语言</li></ul><p>嵌入SQL语句的宿主语言源程序的编译执行</p><ul><li>预编译截断</li><li>编译阶段</li><li>连接装配阶段</li><li>执行阶段</li></ul><p>宿主语言与SQL语言之间的数据传输</p><ul><li>宿主变量：嵌入式SQL可以引用的语言变量</li><li>游标：存储查询结果集合<ul><li>每个查询语句对应于一个游标</li><li>定义游标、打开游标、从游标读拆线呢结果、关闭游标</li></ul></li></ul><h6 id="本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。"><a href="#本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。" class="headerlink" title="本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。"></a>本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统 第七章</title>
    <link href="/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%20%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <url>/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%20%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-物理存储结构"><a href="#第七章-物理存储结构" class="headerlink" title="第七章 物理存储结构"></a>第七章 物理存储结构</h1><p>物理存储介质</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统 第六章</title>
    <link href="/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%20%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2020/06/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%20%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-物理数据库设计"><a href="#第六章-物理数据库设计" class="headerlink" title="第六章 物理数据库设计"></a>第六章 物理数据库设计</h1><ul><li>设计任务：为每个关系模式选择合适的存储结构和存取方法（高效率）</li></ul><h5 id="为关系模式选择存取方法"><a href="#为关系模式选择存取方法" class="headerlink" title="为关系模式选择存取方法"></a>为关系模式选择存取方法</h5><p>常用存取方法：聚集方法、索引方法、hash方法</p><ul><li>聚集方法：<ul><li>把经常进行连接操作的多个关系的记录以连接属性为中心分类存储，从而提高连接操作的效率；</li><li>具有相同连接属性值的记录被物理地存储在一起</li><li>一个物理数据库可以有多个聚集存储</li><li>一个关系只能加入一个句集存储</li></ul></li><li><p>聚集存取方法的选择</p><ul><li>确定聚集关系组：多少个、有哪些<ul><li>经常在一起进行连接操作的关系</li><li>经常出现在相等比较条件中的一组属性</li><li>实例值重复率很高的一个（一组）属性所在的关系</li><li>删去不必要关系<ul><li>经常及进行全局扫描的关系</li><li>删除更新 操作远大于连接操作的关系</li></ul></li></ul></li><li>确定优化的聚集方案</li></ul></li><li><p>索引存取方法</p><ul><li>经常在 查询操作、聚集函数、连接操作的连接条件、投影属性 出现的属性。</li></ul></li><li><p>Hash存取方法的选择</p><ul><li>选择规则：<ul><li>关系大小可预知且不变</li><li>关系大小动态可变且数据库管理系统提供了动态hash存取方法</li><li></li></ul></li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>情感分析读书笔记1</title>
    <link href="/2020/03/18/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2020/03/18/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>​        情感分析课程作业——情感分析与观点挖掘读书笔记——第一、二章</p><a id="more"></a><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h6 id="情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。"><a href="#情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。" class="headerlink" title="情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。"></a>情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。</h6><h3 id="1-1-情感分析的应用"><a href="#1-1-情感分析的应用" class="headerlink" title="1.1 情感分析的应用"></a>1.1 情感分析的应用</h3><p>在生活中，我们寻求他人观点用以：</p><ul><li>个人对商品的选择与购买</li><li>商家了解产品或服务的评价</li><li>政治选举</li></ul><p>为什么要使用情感分析：</p><ul><li>网络上用于发表观点的不同的网站众多</li><li>观点可能隐藏在长篇大论之中</li><li>独自筛选总结困难，因为需要自动的情感分析系统</li></ul><p><strong>意见分析器</strong>（<em>Opinion</em> <em>Parser</em>）</p><h3 id="1-2-情感分析研究"><a href="#1-2-情感分析研究" class="headerlink" title="1.2 情感分析研究"></a>1.2 情感分析研究</h3><h4 id="1-2-1-分析的不同层次"><a href="#1-2-1-分析的不同层次" class="headerlink" title="1.2.1 分析的不同层次"></a>1.2.1 分析的不同层次</h4><p>三个主要层次：</p><ul><li>文档层次：从文章整体角度考虑情感倾向。不适用于评价或比较多个物体的文章。</li><li>句子层次：判断句子的观点（积极、消极、中立），类似于主观性分类。</li><li>实体与方面层次：从某一实体或者某实体的某方面进行分析。</li></ul><p>对于观点的分类：</p><ul><li>普通评论</li><li>比较性评论</li></ul><h4 id="1-2-2-情感词典及相关问题"><a href="#1-2-2-情感词典及相关问题" class="headerlink" title="1.2.2 情感词典及相关问题"></a>1.2.2 情感词典及相关问题</h4><p>尽管情感词汇对于情感分析来说是十分重要的，但是只是使用它们是不够充分的：</p><ul><li>有些词汇不能明确的区分为积极或消极；</li><li>有些句子虽然包含情感词汇，但是只是客观陈述，不表达情感；</li><li>有些句子虽然不包含情感词汇，但是表达出了某些情感；</li><li>存在反语。</li></ul><h4 id="1-2-3-自然语言处理问题"><a href="#1-2-3-自然语言处理问题" class="headerlink" title="1.2.3  自然语言处理问题"></a>1.2.3  自然语言处理问题</h4><p>​        情感分析涉及到自然语言处理的各个方面，许多NLP中的未解问题使得情感分析更加困难。但是由于情感分析不需要完整的了解句子的语义，只需要理解其中的某些方面（观点的积极与消极等），因而也为NLP的研究者们提供了一定的平台。</p><h3 id="1-3-垃圾观点检测"><a href="#1-3-垃圾观点检测" class="headerlink" title="1.3 垃圾观点检测"></a>1.3 垃圾观点检测</h3><p>​        由于人们可以匿名发表一些评论，虽然因此可能会出现一些非常有价值的观点，但是这也导致了恶意评论掩盖真实评论的情况。如果我们要发现这些垃圾观点，就不仅需要自然语言处理，也需要对于数据的挖掘。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h6 id="情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。"><a href="#情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。" class="headerlink" title="情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。"></a>情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。</h6><h3 id="2-1-问题定义"><a href="#2-1-问题定义" class="headerlink" title="2.1 问题定义"></a>2.1 问题定义</h3><h4 id="2-1-1-观点定义"><a href="#2-1-1-观点定义" class="headerlink" title="2.1.1 观点定义"></a>2.1.1 观点定义</h4><p>将一条 <em>opinion</em> 分为四个部分：（<em>g ,s ,h ,t</em> ）</p><ul><li>g —— target 对象</li><li>s —— sentiment 情感</li><li>h —— holder 评论者</li><li>t —— time 时间</li></ul><p>如果进一步考虑，则可以将观点的对象这一实体分为不同的方面考虑，继而则形成了五元组：（<em>e ,a ,s ,h ,t</em> ）,其中：</p><ul><li>e —— entity 实体</li><li>a —— aspect 方面</li></ul><h4 id="2-1-2-情感分析任务"><a href="#2-1-2-情感分析任务" class="headerlink" title="2.1.2 情感分析任务"></a>2.1.2 情感分析任务</h4><p>主要分为以下几个任务：</p><p>​        情感分析的目的、实体分类和表达的定义、各方面分类和表达的定义、显性方面表达的定义、隐形方面表达的定义、实体模型、观点文献的模型</p><p>总结得到六个任务：</p><p>Task1：提取整体并分类</p><p>Task2：提取方面并分类</p><p>Task3：提取观点持有者并分类</p><p>Task4：提取时间并规范化</p><p>Task5：提取情感并分类</p><p>Task6：观点的五部分 <em>(e ,a ,s ,h ,t  )</em>的综合</p><h4 id="2-2-观点总结"><a href="#2-2-观点总结" class="headerlink" title="2.2 观点总结"></a>2.2 观点总结</h4><p>​        由于我们往往需要获取不只一个用户的观点，而是需要统计大量的评论，这使得我们需要对于它们进行总结，需要兼顾质量和数量。</p><h4 id="2-3-观点的不同类型"><a href="#2-3-观点的不同类型" class="headerlink" title="2.3 观点的不同类型"></a>2.3 观点的不同类型</h4><ul><li><p>一般性和比较性观点</p></li><li><p>明确性和暗示性观点</p></li></ul><h4 id="2-4-主观性和情绪"><a href="#2-4-主观性和情绪" class="headerlink" title="2.4 主观性和情绪"></a>2.4 主观性和情绪</h4><p>主观性评论与客观性评论：</p><ul><li>主观评论往往表现了个人的一些观点和感觉，客观则是包含一些事实信息。</li><li>主观评论可能不包含任何感情，客观语句也可能暗示一些情感或观点。</li></ul><p>情感（emotion）：</p><ul><li>主观性的感觉或想法</li><li>五个情感等级<ol><li>emotional negative </li><li>rational negative</li><li>neutral</li><li>rational positive</li><li>emotional positive</li></ol></li></ul><h4 id="2-5-作者及读者立场"><a href="#2-5-作者及读者立场" class="headerlink" title="2.5 作者及读者立场"></a>2.5 作者及读者立场</h4><p>​        不同层次立场的人看待相同的问题可能会产生不同的乃至相反的想法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统2</title>
    <link href="/2020/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2/"/>
    <url>/2020/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统2——关系数据库系统。</p><a id="more"></a><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h6 id="关系模型是由-E-F-Codd-于-1970-年提出的。"><a href="#关系模型是由-E-F-Codd-于-1970-年提出的。" class="headerlink" title="关系模型是由 E.F.Codd 于 1970 年提出的。"></a>关系模型是由 E.F.Codd 于 1970 年提出的。</h6><h4 id="关系模型的组成要素"><a href="#关系模型的组成要素" class="headerlink" title="关系模型的组成要素"></a>关系模型的组成要素</h4><h5 id="三个组成要素"><a href="#三个组成要素" class="headerlink" title="三个组成要素"></a>三个组成要素</h5><ul><li>关系数据结构<ul><li>建立在<strong>集合代数</strong>的基础上</li></ul></li><li>完整性约束<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li><li>关系运算<ul><li>关系代数 —— 基于集合的运算 —— 基于关系代数设计的数据库语言（ISBL）</li><li>关系演算<ul><li>元组演算 —— 基于逻辑的运算 —— 基于元组演算设计的数据库语言（QUEL）</li><li>域演算 —— 基于示例的运算 —— 基于域演算设计的数据库语言（eg：QBE）</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p><strong>基本概念</strong></p><ul><li><p><strong>关系</strong> —— 表</p><ul><li>数据集合</li><li>属性不可再分（关系第一范式）</li></ul></li><li><p><strong>元组</strong>（记录） —— 行 </p><ul><li>任意两个元组不可重复（集合性质）<ul><li>但是很多产品没有遵守这一性质</li></ul></li></ul></li><li><p><strong>属性</strong>（字段、数据项）—— 列</p><ul><li>同质性：每一列中的分量是同类型的，来自同一个域</li><li>不同的列可能出自同一个域</li></ul></li><li><p><strong>域</strong> —— 列的取值范围</p><ul><li>一组具有相同数据类型的值的集合</li></ul></li><li><p><strong>关系模式</strong> —— 大概相当于表头（并不）</p><p>形式：$R(U,D,DOM,I,F)$</p><p>简记为：$R(U)$，若 $U=\{A_1,A_2,…,A_n\}$，也可写为 $R(A_1,A_2,…,A_n)$，n 称为关系的目（或者度）。</p></li><li><p><strong>关系实例</strong>：关系模式在给定时刻的一个快照。时某一时刻现实世界状态的真实反映。</p></li><li><p><strong>关系数据库模式&amp;关系数据库实例</strong></p></li></ul></li><li><p><strong>补充概念</strong></p><ul><li><p><strong>基数</strong>：集合中元素的个数</p></li><li><p><strong>笛卡尔积</strong>：由n个域形成的所有可能的n元组的集合</p><p>$D_1 \times D_2 \times … \times D_n = \{(d_1,d_2,…,d_n) | d_i \in D_i, i = 1,2,…,n \}$</p><p>笛卡尔积的每一个元素成为一个n-元组。</p></li><li><p><strong>分量</strong>：元组中的每一个值叫做一个分量</p></li></ul></li></ul><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><h5 id="各种码的概念"><a href="#各种码的概念" class="headerlink" title="各种码的概念"></a>各种码的概念</h5><ul><li><p><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以<strong>唯一标识一个元组</strong>的。</p></li><li><p><strong>候选码</strong>：最小的超码，一个关系模式中可能不止一个候选码。</p></li><li><strong>主码</strong>：被选定用来区分不同元组的候选码，一个关系模式只有一个。</li><li><strong>主属性</strong>：主码中的属性。</li><li><strong>外码</strong>：关系模式$R_1$的属性中包含另一个关系模式$R_2$中的主码，这个属性集合被称为参照$R_2$的外码。</li></ul><h5 id="关系数据模型的完整性约束"><a href="#关系数据模型的完整性约束" class="headerlink" title="关系数据模型的完整性约束"></a>关系数据模型的完整性约束</h5><ul><li><strong>实体完整性约束</strong>：主码属性值不能为空值。<ul><li>空值：不知道、不存在或者无意义的值。</li></ul></li><li><strong>参照完整性约束</strong>：如果关系$R_1$的外码$F_k$与关系$R_2$的主码$P_k$相对应，则$R_1$中的每一个元组的$F_k$值要等于$R_2$中某个元组的$P_k$值或者为空值。</li><li><strong>用户定义的完整性约束</strong>：用户针对具体的应用程序定义的完整性约束条件。</li></ul><p>（语义完整性约束和函数依赖？）</p><h5 id="DBMS对于完整性的支持"><a href="#DBMS对于完整性的支持" class="headerlink" title="DBMS对于完整性的支持"></a>DBMS对于完整性的支持</h5><ul><li>实体完整性&amp;参照完整性是由DBMS系统字段支持的</li><li>DBMS系统通常会提供以下机制：<ul><li>使得用户可以自行定义有关的完整性约束条件。</li><li>在发生更新时自动检验。</li></ul></li></ul><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><h5 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h5><h6 id="关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。"><a href="#关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。" class="headerlink" title="关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。"></a>关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。</h6><p><strong>关系代数运算</strong></p><ul><li>六种基本运算：选择、投影、并、差、笛卡尔积、重命名。</li><li>其他运算：交、连接、除。（可用基本运算组合定义）</li></ul><p><strong>相容性</strong>：关系 R 与关系 S 存在相容性，当且仅当：</p><ol><li>关系 R 与关系 S 的属性数目相同。</li><li>R 中与 S 中相对应位置的属性的域相同。</li></ol><h6 id="并、差、交运算需满足相容性"><a href="#并、差、交运算需满足相容性" class="headerlink" title="并、差、交运算需满足相容性"></a><em>并、差、交运算需满足相容性</em></h6><p><strong>关系代数基本运算</strong></p><ul><li><strong>并</strong>： $R\cup S = \{t | t \in R \wedge t\in S\}$，其中 $t$ 是元组。</li><li><strong>差</strong>：$R-S = \{t \in R \wedge t\notin S\}$</li><li><strong>笛卡尔积（积）</strong>：$R \times S = \{<a_1,a_2,...,a_n,b_1,...,b_m> | <a_1,a_2,...,a_n>\in R \wedge <b_1,...,b_m> \in S \}$</b_1,...,b_m></a_1,a_2,...,a_n></a_1,a_2,...,a_n,b_1,...,b_m></li><li><strong>选择</strong>：$\sigma_{con}(R)=\{t | t\in R\wedge con(t)\}$<ul><li>$con$为选择谓词，运算符优先次序为：$括号; \theta; \lnot ; \wedge; \vee$ </li></ul></li><li><strong>投影</strong>：$\Pi_{A_1,A_2,…A_k}(R) = \{<t[A_1],t[A_2],...,t[A_k]> | t\in R\}$<ul><li>注意去除重复元组</li></ul></t[A_1],t[A_2],...,t[A_k]></li><li><strong>更名</strong>：$\rho_S (R)$ 或者 $\rho_{S(A_1,…,A_n)}(R)$</li></ul><p><strong>附加运算</strong></p><h6 id="附加运算不增加关系代数的表达能力，但是可以简化常用查询。"><a href="#附加运算不增加关系代数的表达能力，但是可以简化常用查询。" class="headerlink" title="附加运算不增加关系代数的表达能力，但是可以简化常用查询。"></a>附加运算不增加关系代数的表达能力，但是可以简化常用查询。</h6><ul><li><strong>交</strong>：$R \cap  S = \{t |t\in R and t \in S\}$</li><li><strong>连接</strong><ul><li>$\theta$ <strong>连接</strong>：大概是有连接条件的连接</li><li><strong>等值连接</strong>：$\theta$ 为等号的$\theta$ 连接</li><li><strong>自然连接</strong>（$\bowtie$）：要求进行笛卡尔积的两个关系在所有相同属性上的值一致</li></ul></li><li><strong>赋值</strong>：只能赋给临时关系变量，不能增加关系运算的表达能力</li><li><strong>外连接</strong>：（左外连接&amp;右外连接&amp;全外连接）左外是以左边为准，没法匹配的用null填充右边属性。</li><li><strong>除</strong>：$R \div S = \{t | t \in \Pi_z(R) \wedge \forall u \in S (tu \in R) \}$</li></ul><p><strong>其他扩展运算</strong></p><h6 id="可以实现不能有基本的关系代数运算来表达的查询"><a href="#可以实现不能有基本的关系代数运算来表达的查询" class="headerlink" title="可以实现不能有基本的关系代数运算来表达的查询"></a>可以实现不能有基本的关系代数运算来表达的查询</h6><ul><li>广义投影：在投影中使用算术运算和字符</li><li>聚集</li></ul><h5 id="关系演算——元组演算"><a href="#关系演算——元组演算" class="headerlink" title="关系演算——元组演算"></a>关系演算——元组演算</h5><h6 id="非过程化的查询语言，只需要描述所需信息而不需要给出获取过程"><a href="#非过程化的查询语言，只需要描述所需信息而不需要给出获取过程" class="headerlink" title="非过程化的查询语言，只需要描述所需信息而不需要给出获取过程"></a>非过程化的查询语言，只需要描述所需信息而不需要给出获取过程</h6><ul><li><p>表达式：$\{t | P(T)\}$</p><ul><li>所有使得公式P为真的元组t的集合</li></ul></li><li><p>公式P由原子公式构成</p><ul><li>$s \in R; s[x] \Theta u[y]; s[x] \Theta C.$</li></ul></li></ul><h5 id="关系演算——域演算"><a href="#关系演算——域演算" class="headerlink" title="关系演算——域演算"></a>关系演算——域演算</h5><h6 id="使用从属性域中取值的域变量，而不是整个元组的值"><a href="#使用从属性域中取值的域变量，而不是整个元组的值" class="headerlink" title="使用从属性域中取值的域变量，而不是整个元组的值"></a>使用从属性域中取值的域变量，而不是整个元组的值</h6><ul><li>形式化定义：$\{<x_1,...,x_n>|P(x_1,…,x_n)\}$<ul><li>其中$x_1,…,x_n$分别是域变量</li><li>P由原子公式构成</li><li>查询结果时是有包含$<x_1,...,x_n>$且使$P(x_1,…,x_n)$为真的元组</x_1,...,x_n></li></ul></x_1,...,x_n></li></ul><h5 id="关系运算的安全性"><a href="#关系运算的安全性" class="headerlink" title="关系运算的安全性"></a>关系运算的安全性</h5><ul><li>安全关系运算系统：如果一个关系运算系统不产生不限关系和无穷验证则是安全的</li><li>关系代数系统是安全的</li><li>元组演算和域演算是不安全的<ul><li>引入元组关系公式的域的概念，对关系演算进行限制</li></ul></li></ul><h5 id="三者等价性"><a href="#三者等价性" class="headerlink" title="三者等价性"></a>三者等价性</h5><p>下述三者等价：</p><ul><li>基本关系代数</li><li>限制在安全范围内的元组关系演算</li><li>限制在安全范围内的域关系演算</li></ul><h6 id="本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）"><a href="#本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）" class="headerlink" title="本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）"></a>本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统1</title>
    <link href="/2020/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1/"/>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统1——基本知识与关系模型。</p><p>​        参考了中国人民大学的 Mooc 和战神的 Spoc 以及教材。</p><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h4 id="一些名词："><a href="#一些名词：" class="headerlink" title="一些名词："></a><strong>一些名词：</strong></h4><ul><li><p>数据（Data）:描述事物的符号记录。数据与其语义不可分。</p></li><li><p>数据库 （DB）：长期储存在计算机内的、有组织的、可共享的、相互关联的数据的集合。</p></li><li><p>数据库管理系统 （DBMS）：管理数据库的软件系统。</p></li><li><p>SQL（结构化查询语言）：用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。</p></li><li><p>数据库应用程序 （DBAP）</p></li><li><p>数据库系统（DBS）：指在计算机系统中引入数据库后构成的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户构成。</p></li></ul><h4 id="数据库管理技术发展过程"><a href="#数据库管理技术发展过程" class="headerlink" title="数据库管理技术发展过程"></a>数据库管理技术发展过程</h4><p>​    三个阶段：人工管理阶段 $\rightarrow$ 文件系统阶段 $\rightarrow$ 数据库系统阶段</p><p>​    阶段对比如下表（来自人大的Mooc）</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1.assets/image-20200304164606749.png" srcset="/img/loading.gif" alt="image-20200304164606749"></p><h4 id="数据库管理系统功能"><a href="#数据库管理系统功能" class="headerlink" title="数据库管理系统功能"></a>数据库管理系统功能</h4><h5 id="从用户角度考虑"><a href="#从用户角度考虑" class="headerlink" title="从用户角度考虑"></a>从用户角度考虑</h5><ul><li>数据库定义：提供 <strong>数据定义语言（DDL）</strong> 以定义数据格式。</li><li>数据库操纵：提供 <strong>数据操纵语言（DML）</strong>进行数据的<strong>增、删、改、(查)</strong> 操作。</li><li>数据库控制：提供 <strong>数据控制语言（DCL）</strong> 让管理员对于数据的使用进行控制。</li><li>数据库维护：转储、恢复、重组、性能检测、分析等。</li></ul><p><em>DDL、DML、DCL 联合起来就是 SQL语言。（不过这句话我有点疑惑…）</em></p><h5 id="从系统实现角度考虑"><a href="#从系统实现角度考虑" class="headerlink" title="从系统实现角度考虑"></a>从系统实现角度考虑</h5><ul><li>语言编译器：将用数据库语言书写的内容翻译成DBMS的可执行命令。</li><li>查询优化（执行引擎）与查询实现（基本命令的不同执行算法）</li><li>数据存取索引：提供数据在磁盘、磁带等上的高效存取手段。</li><li>通信控制：提供网络环境下的数据库操作与数据传输手段。</li><li>事务管理：提供高可靠性并避免并发操作错误的手段。</li><li>故障恢复：是数据库自动恢复到故障发生前的正常状态的手段。</li><li>安全性控制：提供合法性检验，避免非授权用户非法访问的手段。</li><li>完整性控制：提供数据集数据操作正确性检查的手段。</li><li>应用程序接口（API）：提供应用程序使用DBMS特定功能的手段。</li><li>数据库数据装载、重组等实用程序</li><li>数据库性能分析</li></ul><h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><h4 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h4><p>三层抽象：（不同的 Mooc 称呼不太一样233）</p><ul><li>视图层（外部层次）</li><li>逻辑层（全局层次）</li><li>物理层（内部层次）</li></ul><h4 id="模式与实例"><a href="#模式与实例" class="headerlink" title="模式与实例"></a>模式与实例</h4><p>​    模式——对于数据可逻辑结构和特征的描述、不涉及具体的值且相对稳定。</p><p>​    实例——模式的具体值，是数据库在将某一时刻的状态、随数据库的数据更新而改变。</p><h4 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h4><ol><li>逻辑独立性：用户应用程序与数据库的逻辑结构相互独立。</li><li>物理独立性：用户的应用程序与数据库中数据的的物理存储相互独立。</li></ol><p><em>数据独立性是由DBMS的两层映像保证的。</em></p><h4 id="三级模式与两层映像"><a href="#三级模式与两层映像" class="headerlink" title="三级模式与两层映像"></a>三级模式与两层映像</h4><h5 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a><strong>三级模式</strong></h5><p>​    <em>三级模式与之前的三层抽象相对应</em></p><ul><li>外模式（子模式）—— 局部角度</li><li>逻辑模式 —— 全局角度</li><li>内模式（物理模式、存储模式）</li></ul><h5 id="两层映像"><a href="#两层映像" class="headerlink" title="两层映像"></a><strong>两层映像</strong></h5><p>​    <em>三个层次的联系和转换，由DBMS内部提供</em></p><ul><li>外模式 - 逻辑模式（E-C）映像<ul><li>映像定义通常包含在各外模式描述中。</li><li>保证了数据的逻辑独立性：在逻辑模式发生改变时，数据库管理员可以通过修改E-C映像是的外模式保持不变，从而使得依据外模式编写的应用程序无需修改。</li></ul></li><li>逻辑模式 - 内模式 （C-I）映像<ul><li>映像定义通常包含各逻辑模式描述中。</li><li>保证了数据的物理独立性：物理存储模式发生变化时，通过修改映像使得逻辑模式不变，外模式不变，应用程序不变。</li></ul></li></ul><p>作用：</p><ul><li>保证了应用程序的稳定性，减少了应用程序的维护和修改。</li><li>使得数据定义和描述从应用程序中分离开。</li><li>数据的存取由DBMS管理，简化了应用程序的编制。</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h6 id="这部分主要参考了人大的mooc"><a href="#这部分主要参考了人大的mooc" class="headerlink" title="这部分主要参考了人大的mooc"></a>这部分主要参考了人大的mooc</h6><h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><ol><li><p>概念模型（信息模型）—— 按用户观点考虑、用于数据库设计</p><ul><li>eg：实体—联系模型（E-R模型）</li></ul></li><li>逻辑模型和物理模型<ol><li>逻辑模型 —— 按照计算机系统的观点考虑、用于DBMS的实现<ul><li>网状模型、层次模型</li><li>关系模型</li><li>面向对象（O-O）数据模型、对象关系（O-R）数据模型</li><li>半结构化数据模型</li></ul></li><li>物理模型 —— 对于数据最底层的抽象、描述数据在系统内的表示和存取方法。</li></ol></li></ol><h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><ul><li>数据结构 —— 描述系统的静态特性</li><li>数据操作 —— 描述系统的动态特性</li><li>完整性约束</li></ul><h4 id="层次模型、网状模型与关系模型"><a href="#层次模型、网状模型与关系模型" class="headerlink" title="层次模型、网状模型与关系模型"></a>层次模型、网状模型与关系模型</h4><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>满足以下两个条件的基本层次联系的集合为<strong>层次模型</strong></p><ul><li>有且只有一个节点没有父亲节点——这个节点叫做根节点</li><li>根节点以外的节点有且只有一个父亲节点</li></ul><h6 id="树状哒"><a href="#树状哒" class="headerlink" title="树状哒"></a>树状哒</h6><p><strong>数据结构</strong>——满足下列条件的树</p><ul><li>每个节点代表一个实体</li><li>边表示对象之间的联系</li></ul><p><strong>特点</strong></p><ul><li>只能处理一对多的实体联系（父节点唯一）</li><li>任何记录值都只有按路径查看时才显示全部意义</li><li>没有一个子女记录纸可以推理父亲记录值单独存在</li></ul><p><strong>层次模型的完整性约束</strong></p><ul><li>无相应的父亲节点值就不能插入子女节点值</li><li>删除父亲节点值时，子女节点值也要删除</li><li>更新时，应更新所有相应记录，以保证数据一致性</li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：简单、（对于一对多而言）描述自然直观、易于理解、完整性支持良好</p></li><li><p>缺点：多对多联系表示不自然，插入删除限制多，查询子女节点必须通过父亲节点，面向过程</p></li></ul><h6 id="eg：IMS数据库管理系统（1968）"><a href="#eg：IMS数据库管理系统（1968）" class="headerlink" title="eg：IMS数据库管理系统（1968）"></a>eg：IMS数据库管理系统（1968）</h6><h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p><strong>数据结构</strong>——满足下列条件的图</p><ul><li>每个节点是一个对象记录</li><li>边表示对象之间的联系</li><li>允许多个节点无父亲节点</li><li>允许节点有多个父亲节点</li><li>允许两个节点之间有多种联系</li></ul><h6 id="图状哒"><a href="#图状哒" class="headerlink" title="图状哒"></a>图状哒</h6><p><strong>完整性约束</strong></p><ul><li>允许插入父亲节点值未确定的子女节点值</li><li>允许只删除父亲节点值</li><li>一些具体系统提供了一些完整性约束</li></ul><p><strong>优缺点</strong></p><ul><li>优点：更加直观，性能良好、存取效率高</li><li>缺点：结构复杂，不利于最终用户掌握；DDL、DML语言复杂，不易于用户使用；面型过程</li></ul><h6 id="eg：最早的网状数据库管理系统IDS（1964）"><a href="#eg：最早的网状数据库管理系统IDS（1964）" class="headerlink" title="eg：最早的网状数据库管理系统IDS（1964）"></a>eg：最早的网状数据库管理系统IDS（1964）</h6><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据——信息载体</li><li><p>数据库——数据集合</p></li><li><p>数据库管理系统——软件系统</p></li><li>数据库系统</li></ul><h6 id="本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。"><a href="#本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。" class="headerlink" title="本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。"></a>本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（3）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章-伪随机置换（分组加密）的实际构建"><a href="#第五章-伪随机置换（分组加密）的实际构建" class="headerlink" title="第五章 伪随机置换（分组加密）的实际构建"></a>第五章 伪随机置换（分组加密）的实际构建</h2><h6 id="密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。"><a href="#密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。" class="headerlink" title="密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。"></a>密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。</h6><h3 id="5-1-代替——置换网络"><a href="#5-1-代替——置换网络" class="headerlink" title="5.1 代替——置换网络"></a>5.1 代替——置换网络</h3><p><strong>S盒</strong>（替换盒）：对称密钥加密算法执行替换计算的基本结构。在块密码中，通常被用于模糊密钥与密文之间的关系（香农的混淆理论）</p><h6 id="通常，S-Box接受特定数量的输入比特-m-，并将其转换为特定数量的输出比特-n-，其中-n-不一定等于-m-。一个-m-n-的S-Box可以通过包含-2-m-条目，每条目-n-比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。"><a href="#通常，S-Box接受特定数量的输入比特-m-，并将其转换为特定数量的输出比特-n-，其中-n-不一定等于-m-。一个-m-n-的S-Box可以通过包含-2-m-条目，每条目-n-比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。" class="headerlink" title="通常，S-Box接受特定数量的输入比特$m$，并将其转换为特定数量的输出比特$n$，其中$n$不一定等于$m$。一个$m*n$的S-Box可以通过包含$2^m$条目，每条目$n$比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。"></a>通常，S-Box接受特定数量的输入比特$m$，并将其转换为特定数量的输出比特$n$，其中$n$不一定等于$m$。一个$m*n$的S-Box可以通过包含$2^m$条目，每条目$n$比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。</h6><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140146509.png" srcset="/img/loading.gif" alt="image-20200302140146509"></p><p><strong>P盒</strong>（置换盒）： 是一个透过置换和转置[替换盒（S-boxes）输入进行位元洗牌的方法，在转置的过程中保持一定程度的<a href="https://zh.wikipedia.org/wiki/混淆與擴散" target="_blank" rel="noopener">扩散</a>。 </p><p>置换盒通常分为三类：</p><ul><li>压缩性的——输出位元数比输入少</li><li>扩张性的——输出位元数比输入多</li><li>平直性的——输出位元数等于输入位元数</li></ul><p>其中只有平直性的置换盒是可逆的。</p><p><strong>代替置换网络（SP）</strong>：</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140221062.png" srcset="/img/loading.gif" alt="image-20200302140221062"></p><p><strong>设计原则</strong>：</p><ul><li>S盒的可逆性：在代替置换网络中，S盒必须是可逆的（即必须是单射和满射函数），否则分组函数不能成为一个置换</li><li>雪崩效应：任何分组密码的一个重要特性就是输入的微小改变必然会导致输出的巨大改变，否则两个相似输入所生成的分组密码看起来就不是独立的了。因此，输入的单个比特的变化会影响每一个比特。<ul><li>S盒的设计要使得改变S盒输入的单个比特就能改变S盒输出的至少两个比特</li><li>混合置换的设计要使得任何给定的S盒的输出比特都被传递到下一轮中不同的S盒中</li></ul></li></ul><p><strong>代替置换网络的安全性</strong>：</p><p><strong>对轮数较少的代替转换网络的攻击</strong>：</p><p><strong>攻击三轮代替-置换网络</strong>：</p><h3 id="5-2-Feistel网络"><a href="#5-2-Feistel网络" class="headerlink" title="5.2 Feistel网络"></a>5.2 Feistel网络</h3><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140312519.png" srcset="/img/loading.gif" alt="image-20200302140312519"></p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140333394.png" srcset="/img/loading.gif" alt="image-20200302140333394"></p><h3 id="5-3-DES——数据加密标准"><a href="#5-3-DES——数据加密标准" class="headerlink" title="5.3 DES——数据加密标准"></a>5.3 DES——数据加密标准</h3><h3 id="5-4-增加分组密码的密钥长度"><a href="#5-4-增加分组密码的密钥长度" class="headerlink" title="5.4 增加分组密码的密钥长度"></a>5.4 增加分组密码的密钥长度</h3><h3 id="5-5-AES——高级加密标准"><a href="#5-5-AES——高级加密标准" class="headerlink" title="5.5 AES——高级加密标准"></a>5.5 AES——高级加密标准</h3><h3 id="5-6-差分密码盒线性密码分析简介"><a href="#5-6-差分密码盒线性密码分析简介" class="headerlink" title="5.6 差分密码盒线性密码分析简介"></a>5.6 差分密码盒线性密码分析简介</h3><h2 id="第六章-伪随机对象的理论构造"><a href="#第六章-伪随机对象的理论构造" class="headerlink" title="第六章 伪随机对象的理论构造"></a>第六章 伪随机对象的理论构造</h2><h3 id="6-1-单向函数"><a href="#6-1-单向函数" class="headerlink" title="6.1 单向函数"></a>6.1 单向函数</h3><h5 id="单向函数的定义："><a href="#单向函数的定义：" class="headerlink" title="单向函数的定义："></a>单向函数的定义：</h5><ul><li>令$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$为一个函数，$A$为任意算法，$n$为任意安全参数值：<ul><li>求逆实验$Invert_{A.f}(n)$<ul><li>选择输入$x\leftarrow\{0,1\}^n$，计算$y:=f(x)$</li><li>$1^n$和$y$值作为$A$的输入，输出为$x’$</li><li>如果$f(x’)=y$，那么定义该实验输出为1，否则为0</li></ul></li></ul></li><li><strong>定义</strong>：如果一个函数$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$满足以下两个条件，那么它是单向函数：<ul><li>（易于计算）存在多项式时间算法$M_f$来计算$f$,即对于所有的$x$，有$M_f(x)$</li><li>（反向求逆十分困难）对任意概率多项式时间算法$A$，存在一个可忽略函数$negl$，满足：$Pr[Invert_{A,f}(n)=1]\leqslant negl(n)$<ul><li>也可表示为：$Pr_{x\leftarrow\{0,1\}^n}[A(f(x))∈f^{-1}(f(x))] \leqslant negl(n) $</li></ul></li></ul></li></ul><h5 id="单向置换："><a href="#单向置换：" class="headerlink" title="单向置换："></a>单向置换：</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（2）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章-对称密钥加密及为随机性"><a href="#第三章-对称密钥加密及为随机性" class="headerlink" title="第三章 对称密钥加密及为随机性"></a>第三章 对称密钥加密及为随机性</h2><h3 id="3-1密码学的计算方法"><a href="#3-1密码学的计算方法" class="headerlink" title="3.1密码学的计算方法"></a>3.1密码学的计算方法</h3><h4 id="信息理论安全与计算安全"><a href="#信息理论安全与计算安全" class="headerlink" title="信息理论安全与计算安全"></a>信息理论安全与计算安全</h4><ul><li>信息理论安全：完善保密加密</li><li>计算安全：使用具体方法和渐进方法来定义：<ul><li>具体方法：如果每个运行时间最多为$t$的敌手以最多为$\varepsilon$的概率成功公婆该方案，则称这个方案为$(t,\varepsilon)$安全</li><li>渐进方法：如果每个PPT（多项式时间）敌手以可忽略的概率成功攻破一个方案，那么该方案是安全的<ul><li>注：在任何加密方案中，密钥空间必须足够大，以至于敌手不能变量，或者说，密钥空间的时间规模必须为安全参数的超多项式</li></ul></li></ul></li></ul><h4 id="有效的算法与可忽略的成功概率"><a href="#有效的算法与可忽略的成功概率" class="headerlink" title="有效的算法与可忽略的成功概率"></a>有效的算法与可忽略的成功概率</h4><ul><li><strong>有效计算</strong>：指能够在“概率多项式时间”（PPT）内执行的计算</li><li><strong>可忽略的成功概率</strong>：如果对于每一个多项式$p(.)$，存在一个$N$，使得所有的整数$n&gt;N$，都满足$f(n)&lt;1/p(n)$，则函数$f$是可忽略的</li></ul><h4 id="如何证明某个密码构造是安全的"><a href="#如何证明某个密码构造是安全的" class="headerlink" title="如何证明某个密码构造是安全的"></a>如何证明某个密码构造是安全的</h4><ol><li>指定PPT敌手$A$攻击，并将成功的概率表示为$\varepsilon(n)$</li><li>构造一个叫做”规约“的有效算法$A~’$（区分器？）,该算法将敌手$A$作为子程序来使用，试图解决难题$X$。<img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89.assets/image-20200302140115640.png" srcset="/img/loading.gif" alt="image-20200302140115640"></li><li>如果能成功攻破，那么说明该区分器可以区分这个加密算法所使用的伪随机生成器</li><li>但是根据伪随机生成器的定义，不可被区分</li><li>所以矛盾，证明该算法安全</li></ol><h3 id="3-2-定义计算安全的加密"><a href="#3-2-定义计算安全的加密" class="headerlink" title="3.2 定义计算安全的加密"></a>3.2 定义计算安全的加密</h3><h4 id="窃听者存在情况下的不可区分性"><a href="#窃听者存在情况下的不可区分性" class="headerlink" title="窃听者存在情况下的不可区分性"></a>窃听者存在情况下的不可区分性</h4><p>​    窃听者不可区分实验$PrivK^{eav}_{A,\Pi}(n)$:</p><ul><li>给定输入$1^n$给敌手$A$，$A$输出一对长度相等的消息$m_0$,$m_1$。</li><li>运行$Gen(1^n)$生成以个密钥k，选择一个随机比特$b$，$b∈\{0,1\}$。计算出密文$c=Enc_k(m_b)$，并且给$A$。把$c$叫做挑战密文。</li><li>$A$输出一个比特$b’$</li><li>如果$b=b’$输出1，反之输出0.</li></ul><h5 id="定义：如果对于所有的概率多项式事件敌手-A-存在一个可忽略函数-negl-使得：-Pr-PrivK-eav-A-Pi-lt-1-2-negl-n-则一个对称密钥加密方案-Pi-Gen-Enc-Dec-具备在窃听者存在的情况下不可区分的加密。"><a href="#定义：如果对于所有的概率多项式事件敌手-A-存在一个可忽略函数-negl-使得：-Pr-PrivK-eav-A-Pi-lt-1-2-negl-n-则一个对称密钥加密方案-Pi-Gen-Enc-Dec-具备在窃听者存在的情况下不可区分的加密。" class="headerlink" title="定义：如果对于所有的概率多项式事件敌手$A$,存在一个可忽略函数$negl$使得：$Pr[PrivK^{eav}_{A,\Pi}&lt;= 1/2 +negl(n)$,则一个对称密钥加密方案$\Pi=(Gen,Enc,Dec)$具备在窃听者存在的情况下不可区分的加密。"></a>定义：如果对于所有的概率多项式事件敌手$A$,存在一个可忽略函数$negl$使得：$Pr[PrivK^{eav}_{A,\Pi}&lt;= 1/2 +negl(n)$,则一个对称密钥加密方案$\Pi=(Gen,Enc,Dec)$具备在窃听者存在的情况下不可区分的加密。</h5><h5 id="等价公式：-Pr-output-PrivK-eav-A-Pi-n-0-1-Pr-output-PrivK-eav-A-Pi-n-1-1-lt-negl-n"><a href="#等价公式：-Pr-output-PrivK-eav-A-Pi-n-0-1-Pr-output-PrivK-eav-A-Pi-n-1-1-lt-negl-n" class="headerlink" title="等价公式：$|Pr[output(PrivK^{eav}_{A,\Pi}(n,0))=1]-Pr[output(PrivK^{eav}_{A,\Pi}(n,1))=1]| &lt;= negl(n)$"></a>等价公式：$|Pr[output(PrivK^{eav}_{A,\Pi}(n,0))=1]-Pr[output(PrivK^{eav}_{A,\Pi}(n,1))=1]| &lt;= negl(n)$</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（1）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h1><h2 id="1-2-对称密钥加密"><a href="#1-2-对称密钥加密" class="headerlink" title="1.2 对称密钥加密"></a>1.2 对称密钥加密</h2><p>对称密钥（秘密密钥）：双方共享密码信息（密钥）</p><ul><li>消息本身称为明文</li><li>加密后的消息称为密文</li></ul><p>对称密钥加密方案包含的三个算法：密钥产生、加密、解密</p><ul><li><strong>密钥产生算法（Gen）</strong>：概率算法，根据方案定义的某种分布选择并输出一个密钥<em>k</em></li><li><strong>加密算法（Enc）</strong>：输入密钥<em>k</em>和明文<em>m</em>，输出密文<em>c</em>。记为$Enc_k(m)$</li><li><strong>解密算法（Dec）</strong>：输入密钥<em>k</em>和密文<em>c</em>，输出明文<em>m</em>。记为$Dec_k(c)$</li><li><strong>密钥空间（<em>K</em>）</strong>：密钥产生函数输出的所有可能密钥称为密钥空间</li><li><strong>明文（消息）空间（<em>M</em>）</strong>：所有被加密算法支持的消息的集合</li><li>一个加密方案可由明确三个算法（Gen，Enc，Dec）和明文空间<em>M</em>来完全定义</li></ul><p><strong>攻击场景</strong></p><ul><li><p><strong>唯密文攻击</strong>：仅已知密文</p></li><li><p><strong>已知明文攻击</strong>：已知一个或多个使用相同密钥加密的明文/密文对</p></li><li><p><strong>选择明文攻击</strong>：可以选择明文得到其对应密文</p></li><li><p><strong>选择密文攻击</strong>：可以选择密文得到其对应明文</p></li></ul><h2 id="1-3-古典加密术及其密码分析"><a href="#1-3-古典加密术及其密码分析" class="headerlink" title="1.3 古典加密术及其密码分析"></a>1.3 古典加密术及其密码分析</h2><p><strong>凯撒加密</strong>：移位3字母</p><p><strong>移位加密</strong>:密钥<em>k</em>∈(0,25)，加密时字母移动<em>k</em>个位置</p><p><em>密钥空间充分性原则：任何安全的加密方案必须拥有一个能够抵御穷举搜索的密钥空间</em></p><p><strong>单字母替换（substitution）</strong>：一一映射</p><p><strong>多字母移位加密（Vigenere）</strong>：如图</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/1.png" srcset="/img/loading.gif" alt></p><h1 id="第二章-完善保密加密"><a href="#第二章-完善保密加密" class="headerlink" title="第二章 完善保密加密"></a>第二章 完善保密加密</h1><h2 id="2-1-完善保密加密"><a href="#2-1-完善保密加密" class="headerlink" title="2.1 完善保密加密"></a>2.1 完善保密加密</h2><p><strong>完善保密加密：</strong></p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302123938147.png" srcset="/img/loading.gif" alt="image-20200302123938147"></p><p><strong>完美不可区分性：</strong>密文不包含任何明文信息（密文空间的概率分布独立于明文？）</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135646380.png" srcset="/img/loading.gif" alt="image-20200302135646380"></p><p><strong>敌手不可区分性：</strong>敌手不能区分密文时来自哪个明文的加密</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135906974.png" srcset="/img/loading.gif" alt="image-20200302135906974"></p><p>其中：</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135937398.png" srcset="/img/loading.gif" alt="image-20200302135937398"></p><h2 id="2-2-一次一密（Vernam加密）"><a href="#2-2-一次一密（Vernam加密）" class="headerlink" title="2.2 一次一密（Vernam加密）"></a>2.2 一次一密（Vernam加密）</h2><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135958699.png" srcset="/img/loading.gif" alt="image-20200302135958699"></p><h2 id="2-3-完善保密加密局限"><a href="#2-3-完善保密加密局限" class="headerlink" title="2.3 完善保密加密局限"></a>2.3 完善保密加密局限</h2><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302140015396.png" srcset="/img/loading.gif" alt="image-20200302140015396"></p><h2 id="2-4-香农定理"><a href="#2-4-香农定理" class="headerlink" title="2.4 香农定理"></a>2.4 香农定理</h2><p> 定理：设加密方案 （Gen,Enc,Dec）的明文空间为<em>M</em>，且|<em>K</em>|=|<em>M</em>|=|<em>C</em>|，则当且仅当下列条件成立时，此方案是完善保密加密：</p><ul><li>由Gen产生的任意密钥<em>k</em>∈<em>K</em>的概率都是1/|<em>K</em>|。</li><li>对任意明文<em>m</em>∈<em>M</em>和任意密文<em>c</em>∈<em>C</em>，只存在唯一的密钥<em>k</em>∈<em>K</em>使得$Enc_k(m)$输出<em>c</em>。</li></ul><script type="math/tex; mode=display">a+b=c</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络1</title>
    <link href="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
    <url>/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络 1"></a>计算机网络 1</h1><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><p><strong>计算机网络的定义：</strong>计算机网络是<strong>互联</strong>的，<strong>自治</strong>的计算机集合</p><ul><li>自治：无主从关系</li><li>互联：互联互通</li><li>计算机网络是一种<strong>通信网络</strong></li></ul><p>主机通过<strong>交换网络</strong>互连</p><p><strong>ISP</strong>：因特网服务提供商</p><p><strong>网络协议（协议）</strong>：是为了进行网络中数据交换而建立的规则、标准或约定。它规定了通信实体之间所交换的消息的<strong>格式</strong>、<strong>意义</strong>、<strong>顺序</strong>以及针对收到信息或发生的事件所采取的动作。</p><ul><li>三要素：<ul><li>语法：<em>数据与控制信息的结构或格式；信号电平。</em></li><li>语义：<em>要放发出何种控制信息、完成何种动作、做出何种响应；差错控制。</em></li><li>时序：<em>事件顺序；速度匹配。</em></li></ul></li><li>协议规范了网络中所有信息的发送和接收过程</li></ul><p><strong>计算机网络结构</strong>：</p><ul><li>网络边缘<ul><li>主机（端系统）</li><li>客户/服务器（C/S）应用模型</li><li>对等（P2P）应用模型<ul><li><em>在对等者之间分配任务和工作负载的分布式应用架构</em></li><li><em>网络的参与者共享他们所拥有的一部分硬件资源、这些资源通过网络提供服务和内容，可被其他节点直接访问二无需经过中间实体。</em></li><li><em>既是Server，也是Client。</em></li></ul></li></ul></li><li>接入网络，物理介质:<br>- </li><li>网络核心（核心网络）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
