<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库系统6</title>
    <link href="/2020/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6/"/>
    <url>/2020/07/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统6——查询处理&amp;查询优化。</p><a id="more"></a><h2 id="查询处理"><a href="#查询处理" class="headerlink" title="查询处理"></a>查询处理</h2><h4 id="关系代数操作算法"><a href="#关系代数操作算法" class="headerlink" title="关系代数操作算法"></a>关系代数操作算法</h4><h5 id="选择操作算法"><a href="#选择操作算法" class="headerlink" title="选择操作算法"></a>选择操作算法</h5><ul><li>简单选择操作算法：<ul><li>线性搜索算法<ul><li>顺序读取被操作关系的每个元组</li><li>测试该元组是否满足条件，满足则输出</li></ul></li><li>二元搜索算法<ul><li>条件：按该属性排序</li><li>$O(log(N))$</li></ul></li><li>主索引或者HASH搜索<ul><li>条件：主索引属性或者HASH属性上的相等比较</li></ul></li><li>使用主索引查找满足条件的元组<ul><li>条件：主索引属性上的非相等比较</li></ul></li><li>使用聚集索引查找满足条件的元组<ul><li>具有聚集索引的非键属性上的相等比较</li></ul></li><li>B+树和B树索引搜索算法</li><li>合取选择算法</li><li>使用复合索引的合取选择算法</li></ul></li></ul><h5 id="投影操作算法"><a href="#投影操作算法" class="headerlink" title="投影操作算法"></a>投影操作算法</h5><ul><li>若投影结果中包含码：存取R的所有元组一次即可完成</li><li>若不包含：需要删除重复元组。可利用排序算法实现投影操作</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703221314660.png" srcset="/img/loading.gif" alt="image-20200703221314660" style="zoom:67%;"></li></ul><h5 id="连接操作算法"><a href="#连接操作算法" class="headerlink" title="连接操作算法"></a>连接操作算法</h5><p>$\theta-$连接操作算法：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703222400631.png" srcset="/img/loading.gif" alt="image-20200703222400631" style="zoom:67%;"></p><p>等值连接操作算法：（这里讨论自然连接）</p><ul><li><p>循环嵌套链接（NLJ）</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703222903512.png" srcset="/img/loading.gif" alt="image-20200703222903512" style="zoom:50%;"></p><ul><li>优化：一次读入尽可能多的元组；使用尽可能多的内存块存放外层循环关系的元组；较小的作为外层。</li></ul></li></ul><ul><li><p>排序合并连接（Sort-Merge-Join）</p><p>​    <img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703223933668.png" srcset="/img/loading.gif" alt="image-20200703223933668" style="zoom: 50%;"></p></li></ul><ul><li><p>Hash-连接（Hash-Join）</p><p>​    <img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F6.assets/image-20200703224220132.png" srcset="/img/loading.gif" alt="image-20200703224220132" style="zoom:50%;"></p></li></ul><h5 id="集合操作算法"><a href="#集合操作算法" class="headerlink" title="集合操作算法"></a>集合操作算法</h5><h6 id="输入关系约束：具有相同的属性集合且属性的排列顺序也相同"><a href="#输入关系约束：具有相同的属性集合且属性的排列顺序也相同" class="headerlink" title="输入关系约束：具有相同的属性集合且属性的排列顺序也相同"></a>输入关系约束：具有相同的属性集合且属性的排列顺序也相同</h6><p>方法：利用排序算法在相同的键属性上排序两个操作关系，然后扫描排序后的关系，完成集合操作。</p><h6 id="本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法"><a href="#本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法" class="headerlink" title="本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法"></a>本章重点：掌握个操作的实现算法；掌握关系代数表达式的查询处理方法</h6><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h6 id="使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。"><a href="#使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。" class="headerlink" title="使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。"></a>使用不同的策略处理查询会得到不同的时间开销，需要选择优化的查询处理策略，以减少处理时间，提高系统的处理能力。</h6><h5 id="关系表达式的等价转换规则"><a href="#关系表达式的等价转换规则" class="headerlink" title="关系表达式的等价转换规则"></a>关系表达式的等价转换规则</h5><p>关系代数等价转换规则：</p><ul><li>选择串接率<ul><li>$\sigma_{c1 and…and cn }(E) \equiv \sigma_{c1}(\sigma_{c2}(…(\sigma_{cn}(E))))$</li></ul></li><li>选择交换律<ul><li>$\sigma_{c1}(\sigma_{c2}(E)) \equiv \sigma_{c2}(\sigma_{c1}(E))$</li></ul></li><li>投影交换律<ul><li>$\Pi_{L1}(\Pi_{L2}(…(\Pi_{Ln}(E))…)) \equiv \Pi_{L1}(E)$</li></ul></li><li>选择投影交换律<ul><li>$\Pi_{L}(\sigma_C(E)) \equiv \sigma_C(\Pi_{L}(E)) $ —— C中只涉及L中属性</li><li>$\Pi_{L}(\sigma_C(E)) \equiv \Pi_{L}(\sigma_C(\Pi_{L,B1,B2,…,Bm}(E)))$ ——还涉及其他属性</li></ul></li><li>连接和笛卡尔积的交换律</li><li>集合操作的交换律</li><li>连接、笛卡尔积和集合操作的结合律</li><li>选择、连接和笛卡尔乘积的分配律</li><li>投影、连接和笛卡尔乘积的分配律</li><li>选择与集合操作的分配律</li><li>投影与集合操作的分配律</li><li>其他</li></ul><h5 id="表达式结果大小的估计"><a href="#表达式结果大小的估计" class="headerlink" title="表达式结果大小的估计"></a>表达式结果大小的估计</h5><h6 id="一个操作的代价依赖于它的输入大小和其他统计信息"><a href="#一个操作的代价依赖于它的输入大小和其他统计信息" class="headerlink" title="一个操作的代价依赖于它的输入大小和其他统计信息"></a>一个操作的代价依赖于它的输入大小和其他统计信息</h6><ul><li><p>数据库系统的统计信息</p><ul><li>$n_r$：关系r的元组数</li><li>$b_r$：包含关系r中元组的磁盘块数</li><li>$l_r$：关系r中每个元组的字节数</li><li>$f_r$：关系r的块因子（一个磁盘块中可以容纳r中元组的个数）</li><li>$V(A,r)$：关系r中属性A中出现的非重复值的个数</li></ul></li><li><p>如果假设关系r在物理上存储于一个文件中，则 $b_r = \lceil n_r/ f_r\rceil$</p></li><li><p>当r中A属性上的取值分布是均匀的，运算结果的大小估计如下：</p><ul><li><p>投影$\Pi_A(r)$ ：$V(A,r)$</p></li><li><p>选择$\sigma_{A=a}(R)$： $n_r/V(A,r)$</p></li><li><p>$\sigma_{A \leq v}(R)$： </p><ul><li>$if v &lt; min(A,r)$：0</li><li>$if v &gt; max(A,r)：n_r$</li><li>else：$n_r \times [v-min(A,r)]/[max[A,r]-min(A,r)]$ </li></ul></li><li><p>合取$\sigma_{\theta_1 \wedge…\wedge \theta_k}(R)$： $n_r \times分别的选择估计结果相乘/ n_r^k$</p></li><li><p>析取：$(1-(1-计算结果_1/n_r)\times……)\times n_r$</p></li><li><p>取反$\sigma_{\urcorner\theta}(r)$：无空值——$n_r-s_\theta$</p><p>​                        右空值——$n_r-n_{null}-s_\theta$</p></li><li><p>笛卡尔积：元素个数之积，每个元组占$l_r+l_s$个字节</p></li><li><p>自然连接：RS交集为空：类似笛卡尔积的结果</p><p>​                   RS交集为R的码：小于等于$n_s$</p><p>​                   交集为S中参照R的外码：$n_s$</p><p>​                   不是任何的码：$min(n_r\times n_s/V(A,s),n_s\times n_r/V(A,r))$</p></li><li><p>聚集：$V(A,r)$</p></li><li><p>集合运算：类似于合取、析取、取反的估计方法</p></li><li><p>外连接（结果上界）：</p><ul><li>r左外连接s：自然连接估值+$n_r$</li><li>r右外连接s：自然连接估值+$n_s$</li><li>r全外连接s：自然连接估值+$(n_r+n_s)$</li></ul></li></ul></li><li><p>当r中A属性上的取值分布不均匀的，可以采用直方图等统计方法统计方法进行结果大小估计。</p></li></ul><h5 id="启发式关系代数优化算法"><a href="#启发式关系代数优化算法" class="headerlink" title="启发式关系代数优化算法"></a>启发式关系代数优化算法</h5><ul><li><p>启发式代数优化规则</p><h6 id="给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）"><a href="#给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）" class="headerlink" title="给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）"></a>给定一个关系代数表达式，可以应用一组启发式规则对其进行等价变换，产生一个具有较高效率的等价表达式。（不能保证一定产生最优化等价表达式）</h6><ul><li><p>选择和投影操作尽早执行</p></li><li><p>把某些选择操作与笛卡尔积相结合，形成一个连接操作</p></li><li>同时执行相同关系上的多个选择和投影操作</li><li>把投影操作与连接操作结合起来执行</li><li>提取公共表达式（如果一个反复出现的公共表达式结果不是很大，且从外存读入的时间小于计算时间，可以组织计算一次并存储结果）</li></ul></li><li><p>启发式代数优化算法</p><ul><li>构造查询的内部表示是查询处理的第一步。给定一个用高级语言定义的查询，需要两步来构造该查询的内部表示。<ul><li>把高级语言定义的查询转换为关系代数表达式<ul><li>使用from从句中的关系构造笛卡尔积，然后再这个基础上构造选择操作，最后构造投影操作</li></ul></li><li>把关系代数表达式转化为查询树</li></ul></li><li>算法流程：<ul><li>把每个选择操作$\sigma_{C1 and….and Cn}(E)$转化为$\sigma_{C1}(…(\sigma_{Cn}(E))…)$</li><li>把每个选择操作移到尽可能靠近叶结点</li><li>把每个投影操作尽可能靠近叶结点</li><li>把串接的多个选择或多个投影操作组合为单个的选择或投影操作</li><li>重新安排叶结点，使既有最小选择操作的叶结点最先执行</li><li>组合笛卡尔积和相继的选择操作形成连接操作</li><li>把最后的查询树划分为多个子树，使得每个子树上的操作可以由单个存取程序一次完成，划分方法如下：<ul><li>每个耳目操作在且仅在一个子树中</li><li>如果二目操作a在子树t中，而且从叶到根的方向的路径b$\rightarrow$a是仅包含一目操作的最长路径，则b$\rightarrow$a也包含在t中</li></ul></li><li>产生一个计算最后查询树的程序，每一步计算一个子树</li></ul></li></ul></li></ul><p>基于复杂性估计的查询优化算法</p><p>两个阶段：</p><ul><li>用启发式优化算法产生逻辑上优化的关系代数表达式或查询计划p</li><li>为p中每个关系代数操作选择具有最小复杂性的实现算法，确定p的优化执行策略p(A)</li><li>影响查询执行效率的主要因素是磁盘存取块数</li></ul><h6 id="本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。"><a href="#本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。" class="headerlink" title="本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。"></a>本章重点：熟练掌握关系代数表达式等价变换规则；掌握启发式查询优化算法。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统5</title>
    <link href="/2020/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5/"/>
    <url>/2020/07/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F5/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统5——物理存储结构。</p><a id="more"></a><h2 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h2><h5 id="数据库存储设备"><a href="#数据库存储设备" class="headerlink" title="数据库存储设备"></a>数据库存储设备</h5><p>高速缓冲存储器（Cache）：最快价格昂贵的存储介质，由计算机的硬件管理</p><p>主存储器：存放可处理数据，快、贵、数据易丢失</p><p>快闪存储器：断电故障可保存，相对价低，读速几乎与贮存想要，写稍慢，擦除更慢——固态硬盘</p><p>磁盘存储器：长期存储，进行操作时需先读入主存、慢</p><ul><li>多个磁盘组装成磁盘组，每个磁盘表面由多个磁道组成（数据存储在磁道上），每个磁道分为多个扇区（磁盘块），在磁盘组上所有磁盘面具有相同直径的磁道的集合称为一个柱面。</li><li>磁盘存储器由磁盘和驱动器构成，磁头和磁臂。分类：固定头磁盘存储器和活动头磁盘存储器</li><li>寻址方式：柱面号+面号+扇区号</li><li>代价：寻找使劲按+旋转延迟+传输时间</li><li>磁盘缓冲区理技术：最近最少使用、立即丢弃、最近最多使用</li><li>磁盘扫描策略：先来先服务、近者优先、全程移动、移动扫描、分组扫描、间歇式全程扫描</li><li>磁盘容错技术——基于磁盘冗余技术的策略（独立磁盘冗余阵列）<ul><li>RAID1：一对一</li><li>RAID4：一个冗余盘完成n个的奇偶校验。所有磁盘同一位置1的个数是偶数则为0，否则1。 问题：冗余盘读写次数太多</li><li>RAID5：每个磁盘作为某些磁盘的冗余磁盘</li></ul></li></ul><p>光学存储器：比磁盘慢很多</p><p>磁带存储器：顺序存储访问、十分慢、十分便宜（磁带驱动器贵）</p><h5 id="磁盘文件"><a href="#磁盘文件" class="headerlink" title="磁盘文件"></a>磁盘文件</h5><p>数据项——属性值</p><p>文件记录——元组</p><p>文件块——记录集合、一个磁盘块</p><p>文件——一个关系</p><ul><li><p>种类：无需文件、有序文件、索引文件、Hash文件</p></li><li><p>文件的存储方法：</p><ul><li><p>连续存储方法：按文件块顺序把文件存储到连续的磁盘块上</p><ul><li>存取整个文件的效率高，但扩充困难</li></ul></li><li><p>链接存储方法</p><ul><li>增加指向像一个文件块所在的磁盘块的地址指针</li><li>便于扩充，但整个读取慢</li></ul></li><li><p>索引存储方法</p><ul><li>在磁盘上存储一个或多个索引块，每个索引块包含指向文件块的指针</li><li>查询处理高效</li></ul></li></ul></li></ul><h5 id="Hash文件"><a href="#Hash文件" class="headerlink" title="Hash文件"></a>Hash文件</h5><p>简单HASH</p><ul><li>桶溢出（文件记录在Hash属性上分布不均匀）</li><li>解决：多重Hash（设置溢出处理Hash函数）、链接法（每个桶设置一个磁盘块链表，用于超出部分存储）</li><li>缺点：只能有效地支持在Hash码上具有相等比较的数据操作；文件记录少时浪费大量存储空间；磁盘块链过长时影响记录存取效率。</li></ul><p>动态Hash</p><ul><li>Hash桶与磁盘块一一对应</li><li>Hash桶数量不固定，不断分裂</li><li>二叉树表示：内节点左0右1，叶节点存储指针<ul><li>分裂&amp;合并</li></ul></li><li>优点：查找记录时只需查找一个存储块</li><li>缺点：同增长速度快，可能内存放不下，影响其他数据，波动较大</li></ul><h5 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h5><p>索引时一种数据结构，通常是有序文件</p><p>索引也是文件——索引文件</p><ul><li>索引文件的记录称为索引记录（项）</li><li>索引记录包括两个域：搜索码&amp;指针</li><li><p>索引文件一般远小于数据文件</p></li><li><p>多级索引</p></li><li><p>按结构分类：</p><ul><li>稀疏索引：所有记录按关键字值分组（管理方便但更新代价高）<ul><li>主索引常常是稀疏索引</li></ul></li><li>稠密索引：每个记录一个索引项（有序操作方便但复杂）</li></ul></li><li><p>按索引域特点分：</p><ul><li>主索引（常常是聚集索引）</li><li>辅助索引（一定是稠密索引）</li></ul></li></ul><h5 id="B-树和B树文件索引"><a href="#B-树和B树文件索引" class="headerlink" title="B+树和B树文件索引"></a>B+树和B树文件索引</h5><p>略</p><h6 id="本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B-树的索引结构。"><a href="#本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B-树的索引结构。" class="headerlink" title="本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B+树的索引结构。"></a>本章重点：掌握文件、文件记录；掌握索引文件（主索引、聚集索引、辅助索引、多级索引）、数据字典、B+树的索引结构。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统4</title>
    <link href="/2020/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4/"/>
    <url>/2020/06/30/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F4/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统4——设计篇：概念数据库设计、逻辑数据库设计、物理数据库设计。</p><a id="more"></a><h2 id="数据库设计概述与需求分析"><a href="#数据库设计概述与需求分析" class="headerlink" title="数据库设计概述与需求分析"></a>数据库设计概述与需求分析</h2><p>概念：对于一个给定的应用领域，设计优化的数据库逻辑和物理结构，使之满足用户的<strong>信息管理要求</strong>和<strong>数据操作要求</strong>，有效地支持各种应用系统的开发和运行。</p><ul><li>信息管理要求：在数据库中应该存储和管理哪些数据对象</li><li>数据操作要求：对数据对象需要进行哪些操作</li></ul><h5 id="数据库设计目标"><a href="#数据库设计目标" class="headerlink" title="数据库设计目标"></a>数据库设计目标</h5><p>为用户和各种应用系统提供一个基础设施和高效的运行环境</p><ul><li>数据信息完整、冗余度低</li><li>存取效率高</li><li>运行管理效率高</li></ul><h5 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h5><h6 id="中心：用户需求"><a href="#中心：用户需求" class="headerlink" title="中心：用户需求"></a>中心：用户需求</h6><p>数据库设计包括：</p><ul><li>设计数据库模式</li><li>设计访问和更新数据的程序</li><li>设计数据访问的安全模式</li></ul><p>各级模式形成过程：</p><p>需求分析$\rightarrow$概念数据库设计$\rightarrow$逻辑数据库设计$\rightarrow$物理数据库设计</p><ul><li>需求分析：综合应用需求</li><li>概念数据库设计：形成概念模式（E-R图）</li><li>逻辑数据库设计：首先将E-R图转换成数据模型（如关系模型），形成逻辑模式，再根据安全性和用户需求形成外模式</li><li>物理数据库设计：进行物理存储安排</li></ul><h2 id="概念数据库设计"><a href="#概念数据库设计" class="headerlink" title="概念数据库设计"></a>概念数据库设计</h2><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>设计任务：</p><ul><li>概念数据库模式设计</li><li>事务设计</li></ul><p>概念数据库模式独立于任何数据库管理系统，不能直接用于数据库的实现。</p><p>用于概念数据库设计的高级数据模型——实体联系模型</p><h5 id="实体联系（E-R）模型"><a href="#实体联系（E-R）模型" class="headerlink" title="实体联系（E-R）模型"></a>实体联系（E-R）模型</h5><p>三个主要元素：实体、属性、联系</p><p><strong>实体</strong></p><ul><li>ER模型的基本对象</li><li>每个实体都有一组特征或性质——<strong>属性</strong><ul><li>实体属性的一组特定值确定了一个特定的实体</li><li>实体的属性值是数据库中存储的主要数据</li></ul></li><li><strong>实体集</strong>：相同类型的实体的集合<ul><li>实体集不必互不相交</li></ul></li></ul><p><strong>属性</strong></p><ul><li>单值属性、多值属性<ul><li>一些属性的取值可能是多个（eg：联系方式）</li></ul></li><li>简单属性、复合属性<ul><li>符合熟悉具有层次结构（eg：家庭住址可再分）</li></ul></li><li>派生属性<ul><li>可以由其他属性导出（eg：年龄可由生日导出）</li></ul></li><li>码的概念</li></ul><p><strong>联系</strong></p><ul><li><p>不同实体集的实体之间存在的某种关联</p></li><li><p><strong>联系集</strong>：同类联系的集合</p><ul><li>称一个联系集所关联的实体集的数量为这个联系集的阶</li><li>阶为n的联系集称为n元联系集</li><li>联系集的属性</li></ul></li><li><p>约束</p><ul><li>映射基数<ul><li>一个实体通过一个联系能关联的实体的个数<ul><li>一对一、一对多、多对多</li></ul></li></ul></li><li>参与约束<ul><li>全城关联约束<ul><li>eg：每个教研室必须属于一个系，则教研室实体集与属于联系集有全程关联约束</li></ul></li><li>部分关联约束<ul><li>eg：不是每个教师都是主任</li></ul></li></ul></li></ul></li><li><p>弱实体集</p><ul><li><p>必须有一个或多个属性，使得这些属性可以与主实体集的码相结合，形成相应弱实体的码</p><ul><li>上述属性称为弱实体集的<strong>部分码</strong></li><li>eg：父亲实体集与孩子实体集（不同父亲的孩子名字可以相同，同一个父亲的孩子姓名一定不同）</li></ul></li></ul></li></ul><p><strong>实体联系图（ER图）</strong></p><p>这部分略了先qvq…</p><p><strong>事务设计</strong></p><ul><li><p>事务：一个或多个数据操作构成的集合，这组操作满足原子性</p></li><li><p>设计任务：定义事务功能、说明事务的输入输出。</p></li></ul><h6 id="本章重点：实体联系模型、实体联系图、账务概念数据库设计方法"><a href="#本章重点：实体联系模型、实体联系图、账务概念数据库设计方法" class="headerlink" title="本章重点：实体联系模型、实体联系图、账务概念数据库设计方法"></a>本章重点：实体联系模型、实体联系图、账务概念数据库设计方法</h6><h2 id="逻辑数据库设计"><a href="#逻辑数据库设计" class="headerlink" title="逻辑数据库设计"></a>逻辑数据库设计</h2><p>设计任务：把概念数据库设计产生的概念数据库模式变换为逻辑数据库模式。</p><ul><li>ER图$\rightarrow$关系表</li></ul><p>逻辑数据库设计的步骤</p><ul><li>形成初始关系数据库模式</li><li>关系模式规范化</li><li>关系模式优化</li><li>定义关系上的完整性和安全性约束</li><li>子模式定义</li><li>性能估计</li></ul><h5 id="形成初始关系模式"><a href="#形成初始关系模式" class="headerlink" title="形成初始关系模式"></a>形成初始关系模式</h5><ul><li>普通实体集变换</li><li>弱实体的变换<ul><li>主实体集的码和弱实体集的部分码构成关系的主码</li></ul></li><li>多值属性的变换<ul><li>为每个多值属性建立一个关系</li></ul></li><li>实体间联系的变换<ul><li>一对一：在其中一个关系中增加有关信息、或建立单独关系</li><li>一对多：可以不建立新关系、也可以建立</li><li>多对多：建立新关系</li><li>n元联系的变换：和多对多类似</li></ul></li></ul><h5 id="关系模式规范化"><a href="#关系模式规范化" class="headerlink" title="关系模式规范化"></a>关系模式规范化</h5><h6 id="为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题"><a href="#为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题" class="headerlink" title="为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题"></a>为了避免由函数依赖引起的冗余问题、插入问题、更新问题和删除问题</h6><p><strong>函数依赖</strong></p><ul><li><p>定义：设R是一个关系模式，U是R的属性集合，X和Y是U的子集。对于R的任意实例ｒ，ｒ中任意两个元组t1和t2，如果t1[X]=t2[X]，则t1[Y]=t2[Y]，我们称X函数地确定Y，或Y函数依赖于X，记作X→Y。</p><ul><li>如果X→Y且Y不是X的子集，则称X→Y是<strong>非平凡函数依赖</strong></li><li>如果X→Y，称X为这个函数依赖的<strong>决定属性集</strong></li></ul></li><li><p>完全函数依赖与部分函数依赖</p><ul><li>X取任何真子集都不能使依赖成立——完全函数依赖</li></ul></li><li><p>传递地函数依赖</p></li><li><p>各种码：</p><ul><li>超码：可以唯一地识别关系的元组</li><li>候选码：超码且不能取真子集</li><li>主码：被选中的孩子！（x候选码）</li><li>键属性：包含在某个候选码中的属性</li><li>非键属性：不包含在任何候选码中的属性</li><li>全键：候选码包含所有属性</li><li>外码：某个属性子集合是另一个关系模式的主码</li></ul></li></ul><p><strong>函数依赖的公理系统</strong></p><h6 id="Armstrong公理系统——模式分解算法的理论基础"><a href="#Armstrong公理系统——模式分解算法的理论基础" class="headerlink" title="Armstrong公理系统——模式分解算法的理论基础"></a>Armstrong公理系统——模式分解算法的理论基础</h6><ul><li><p>设R是一个具有属性集合U的关系模式，F是R上的函数依赖集合。如果对于R的任何一个使F称的关系实例r，函数依赖X→Y都成立，则称F逻辑蕴含X→Y。</p></li><li><p>Armstrong公理系统</p><ul><li>自反率：$Y \subseteq X \subseteq U,$则 X→Y 为F所蕴含。</li><li>增广率：若 X→Y 为F所蕴含，且$Z \subseteq U$，则XZ→YZ为F所蕴含。</li><li>传递率：若 X→Y 及 Y→Z 为F所蕴含，则 X→Z为F所蕴含。</li><li>导出规则：<ul><li>合并规则（左部相同右部可合并）</li><li>伪传递规则（X→Y，WY→Z，则XW→Z）</li><li>分解规则（Z $\subseteq$ Y，X→Y，则X→Z）</li></ul></li></ul></li><li><p>闭包：大概就是给的能推出来的都加进去</p></li><li><p>对于给定关系模式和函数依赖集，可将属性分为四类</p><ul><li>L类：仅出现在函数依赖左部<ul><li>必为任一候选码的成员</li></ul></li><li>R类：仅出现在右部<ul><li>不在任何候选码中</li></ul></li><li>N类：在两边都未出现<ul><li>必包含在任一候选码中</li></ul></li><li>LR类：两边都出现</li><li>推论：如果X是N、L两类属性组成的属性集且X的闭包包含了R的全部属性，则X是R的候选码</li></ul></li><li><p>极小函数依赖集：</p><ul><li>F中任一函数依赖右部仅含有一个属性</li><li>不存在X→Y使得F与F-{X→Y}等价</li><li>不存在X→Y，X有真子集Z使得F-{X→Y}∪{Z→Y}与F等价</li><li>极小函数依赖集不唯一</li></ul></li><li><p>计算极小函数依赖集的方法:</p><ul><li>拆分右部</li><li>逐一去掉某函数依赖（X→Y）判断剩余是否仍满足X→Y（计算闭包）</li><li>逐一判断能否去掉右部某一部分使其仍成立</li></ul></li></ul><p><strong>关系模式的规范形式</strong></p><h6 id="1NF-supset-2NF-supset-3NF-supset-BCNF-supset-4NF"><a href="#1NF-supset-2NF-supset-3NF-supset-BCNF-supset-4NF" class="headerlink" title="$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF$"></a>$1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF$</h6><ul><li><p>第一范式（1NF）</p><ul><li>每个属性的值域是不可分的简单数据项的集合</li><li>问题<ul><li>插入异常、删除异常、数据冗余度大、修改复杂</li></ul></li><li>存在部分函数依赖</li></ul></li><li><p>第二范式（2NF）</p><ul><li>每一个非键属性都完全函数依赖于候选码</li><li>可以由1NF模式分解得到多个2NF，减轻了问题。</li><li>存在非键属性对候选码的传递函数依赖</li></ul></li><li><p>第三范式（3NF）</p><ul><li>任何一个非键属性都不传递依赖与任何候选码</li><li>仍不能完全消除问题</li><li>键属性部分依赖于候选码</li></ul></li><li><p>BC范式（BCNF）</p><ul><li>1NF且对于每个函数依赖，左部必为候选码</li><li>性质：<ul><li>所有非键属性都完全依赖于每个候选码</li><li>所有键属性都完全依赖于不包含它的候选码</li><li>没有任何属性依赖于非键的一组属性</li></ul></li><li>满足BCNF一定满足3NF</li><li>效处理插入和删除异常</li></ul></li></ul><p><strong>关系模式的分类</strong></p><ul><li>静态关系：一旦数据已经加载，只能查询不能插入删除更新<ul><li>需满足1NF</li></ul></li><li>动态关系：经常插入删除更新<ul><li>需满足3NF</li></ul></li></ul><h6 id="不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）"><a href="#不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）" class="headerlink" title="不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）"></a>不能说规范化程度越高的关系模式就越好（考虑实际情况和用户需求）</h6><p>分解时的要求：既可以通过自然连接恢复为原来的关系（无损连接性），也不丢失函数依赖</p><p>判断无损连接性：分解后的函数依赖的并集是否完全包含原本的函数依赖集</p><p><strong>分解为具有无损连接和保持函数依赖的3NF</strong></p><ul><li>根据绩效函数依赖及合并左部相同部分</li><li>分解后判断是否包含候选码，不包含加入</li><li>合并包含关系</li></ul><h5 id="关系模式优化"><a href="#关系模式优化" class="headerlink" title="关系模式优化"></a>关系模式优化</h5><h6 id="提高数据的操作效率和存储空间利用率"><a href="#提高数据的操作效率和存储空间利用率" class="headerlink" title="提高数据的操作效率和存储空间利用率"></a>提高数据的操作效率和存储空间利用率</h6><p>常用分解方法</p><ul><li>水平分解：把元组分成若干个子集，定义每个子集为一个子关系</li><li>垂直分解：需要注意保持无损连接性和函数依赖</li></ul><h5 id="定义关系上的完整性和安全性约束"><a href="#定义关系上的完整性和安全性约束" class="headerlink" title="定义关系上的完整性和安全性约束"></a>定义关系上的完整性和安全性约束</h5><ul><li>完整性约束<ul><li>属性上的完整性约束</li><li>多个属性键的完整性约束</li><li>不同关系模式的完整性约束</li></ul></li><li>安全性约束<ul><li>属性上的安全性约束</li><li>关系模式上的安全性约束</li></ul></li></ul><h5 id="子模式定义"><a href="#子模式定义" class="headerlink" title="子模式定义"></a>子模式定义</h5><p>利用视图定义外模式</p><ul><li>属性重命名</li><li>不同级别不同视图</li><li>简化用户使用</li></ul><h5 id="性能估计"><a href="#性能估计" class="headerlink" title="性能估计"></a>性能估计</h5><h6 id="对时间复杂性和空间复杂性进行估算"><a href="#对时间复杂性和空间复杂性进行估算" class="headerlink" title="对时间复杂性和空间复杂性进行估算"></a>对时间复杂性和空间复杂性进行估算</h6><p>三个测度：逻辑记录存取数、信息传输量、存储空间占用量</p><h6 id="本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。"><a href="#本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。" class="headerlink" title="本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。"></a>本章小结：熟练掌握实体联系模型向关系模式的转换；掌握函数依赖，Armstrong公理系统，各种NF；掌握无损连接性、函数依赖保持性，关系模式分解算法。</h6><h2 id="物理数据库设计"><a href="#物理数据库设计" class="headerlink" title="物理数据库设计"></a>物理数据库设计</h2><h6 id="设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许"><a href="#设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许" class="headerlink" title="设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许"></a>设计任务：选择合适的存储结构和存取方法，是数据库上的事务可以高效率允许</h6><p>设计步骤</p><ul><li>分析影响物理数据库设计因素</li><li>为关系模式选择存取方法</li><li>设计关系、索引等数据库文件的物理存储结构</li></ul><p>常用存取方法</p><ul><li>聚集方法<ul><li>把经常进行连接操作的多个关系的记录以链接属性为中心分类存储</li><li>一个物理数据库可以由多个聚集存储，但是一个关系只能加入一个聚集存储</li><li>选择方法<ul><li>确定聚集关系组：<ul><li>经常连接操作的关系</li><li>一个关系的某组属性经常出现在相等比较条件中</li><li>某一（组）属性实例重复率很高</li><li>取消不必要关系：经常全关系扫面的，更细删除操作远大于连接操作的。</li></ul></li><li>确定优化的聚集方案</li></ul></li></ul></li><li>索引方法<ul><li>确定候选索引方法：<ul><li>经常出现在查询操作条件</li><li>经常作为聚集函数参数</li><li>经常在连接操作的连接条件中</li><li>经常作为投影属性使用</li></ul></li><li>索引存取方法的选择</li></ul></li><li>HASH方法<ul><li>选择规则：经常出现在相等连接操作条件中或相等比较选择条件中，且满足：<ul><li>如果关系大小可预知且不变</li><li>如果关系大小动态改变且数据库管理系统提供了动态HSAH存取方法</li></ul></li></ul></li></ul><p>物理存储结构设计</p><p>确定如何在磁盘存储器上存储关系、索引和聚集，使得空间利用率最大化，数据操作引起的系统开销最小化。</p><h6 id="本章重点：掌握数据库物理存储结构和存取方法的设计"><a href="#本章重点：掌握数据库物理存储结构和存取方法的设计" class="headerlink" title="本章重点：掌握数据库物理存储结构和存取方法的设计"></a>本章重点：掌握数据库物理存储结构和存取方法的设计</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统3</title>
    <link href="/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3/"/>
    <url>/2020/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统3——结构化查询语言SQL。</p><a id="more"></a><h2 id="SQL查询语言概览"><a href="#SQL查询语言概览" class="headerlink" title="SQL查询语言概览"></a>SQL查询语言概览</h2><h5 id="SQL语言的几个部分"><a href="#SQL语言的几个部分" class="headerlink" title="SQL语言的几个部分"></a>SQL语言的几个部分</h5><p>数据定义语言（DDL）：提供定义关系模式、删除关系以及修改关系模式的命令</p><p>数据操纵语言（DML）：提供从数据中查询信息、插入删除修改元组的能力</p><p>完整性：SQL DDL 包括定义完整性的约束命令</p><p>视图定义：SQL DDL 包括定义视图的命令</p><p>事务控制：定义事务的开始和结束</p><p>嵌入式SQL和动态SQL：如何将SQL陷入到通用编程语言</p><p>授权：SQL DDL 包括定义访问权限的命令</p><p>SQL语言特点：</p><ul><li>综合统一</li><li>高度非过程化</li><li>面向集合的操作方式</li><li>简便易学易用</li></ul><h2 id="SQL数据定义"><a href="#SQL数据定义" class="headerlink" title="SQL数据定义"></a>SQL数据定义</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215355571.png" srcset="/img/loading.gif" alt="image-20200629215355571"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215530535.png" srcset="/img/loading.gif" alt="image-20200629215530535"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215715100.png" srcset="/img/loading.gif" alt="image-20200629215715100"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629215841656.png" srcset="/img/loading.gif" alt="image-20200629215841656"></p><h2 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h2><p>单表查询</p><ul><li>最简单、仅涉及一个表</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629221054876.png" srcset="/img/loading.gif" alt="image-20200629221054876" style="zoom: 67%;"></li></ul><p>连接查询</p><ul><li>同时涉及到多个表的查询</li><li>连接条件</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629221144057.png" srcset="/img/loading.gif" alt="image-20200629221144057" style="zoom:67%;"></li></ul><p>嵌套子查询</p><ul><li>将一个查询块嵌套在另一个查询块的where、from、having语句条件中的查询</li><li>由里向外处理</li><li>子查询不能使用order by</li><li>有些嵌套查询可以用连接运算替代</li></ul><p>集合查询</p><ul><li>并（union）、交（intersect）、差（except）</li><li>参加集合操作的各结果表列数和对应数据类型必须相同</li></ul><h2 id="SQL数据库的修改"><a href="#SQL数据库的修改" class="headerlink" title="SQL数据库的修改"></a>SQL数据库的修改</h2><h5 id="SQL语言数据更新机制"><a href="#SQL语言数据更新机制" class="headerlink" title="SQL语言数据更新机制"></a>SQL语言数据更新机制</h5><ul><li>DBMS在执行插入、修改及删除语句时会检查元组是否会破坏表上已定义的完整性规则</li></ul><h2 id="SQL事务"><a href="#SQL事务" class="headerlink" title="SQL事务"></a>SQL事务</h2><p>事务是由查询或更新语句序列组成的</p><ul><li>Commit：提交当前事务（永久保存）</li><li>Rollback：回滚当前事务（撤销该事务中所有SQL语句对数据库的更新）</li><li>事务具有原子性</li><li>定义语句：begin atomic … end</li></ul><h2 id="SQL触发器"><a href="#SQL触发器" class="headerlink" title="SQL触发器"></a>SQL触发器</h2><p>触发器（trigger）</p><ul><li>一条语句，对数据修改时自动执行</li><li>设置触发器机制的两个要求：<ul><li>指明执行条件</li><li>指明触发器动作</li></ul></li><li>一旦把一个触发器输入数据库，只要指定的事件发生，相应条件满足，数据库系统就有责任执行它</li><li><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629223204596.png" srcset="/img/loading.gif" alt="image-20200629223204596" style="zoom: 50%;"></li></ul><h2 id="SQL数据库授权机制"><a href="#SQL数据库授权机制" class="headerlink" title="SQL数据库授权机制"></a>SQL数据库授权机制</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629224049807.png" srcset="/img/loading.gif" alt="image-20200629224049807" style="zoom:67%;"></p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F3.assets/image-20200629224100841.png" srcset="/img/loading.gif" alt="image-20200629224100841" style="zoom:67%;"></p><h2 id="嵌入式SQL语言"><a href="#嵌入式SQL语言" class="headerlink" title="嵌入式SQL语言"></a>嵌入式SQL语言</h2><p>嵌入式SQL</p><ul><li>可以在程序设计语言中使用的SQL语言</li><li>这种程序设计语言被称为宿主语言</li></ul><p>嵌入SQL语句的宿主语言源程序的编译执行</p><ul><li>预编译截断</li><li>编译阶段</li><li>连接装配阶段</li><li>执行阶段</li></ul><p>宿主语言与SQL语言之间的数据传输</p><ul><li>宿主变量：嵌入式SQL可以引用的语言变量</li><li>游标：存储查询结果集合<ul><li>每个查询语句对应于一个游标</li><li>定义游标、打开游标、从游标读拆线呢结果、关闭游标</li></ul></li></ul><h6 id="本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。"><a href="#本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。" class="headerlink" title="本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。"></a>本章重点：熟练使用SQL语言进行数据定义、数据查询、数据修改；掌握完整性约束、视图操作。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>情感分析读书笔记1</title>
    <link href="/2020/03/18/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2020/03/18/%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>​        情感分析课程作业——情感分析与观点挖掘读书笔记——第一、二章</p><a id="more"></a><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h6 id="情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。"><a href="#情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。" class="headerlink" title="情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。"></a>情感分析，又叫做观点挖掘，是研究分析人类对于某些实体，如产品、服务、组织、个体、问题、事件、话题及它们的属性等的观点、情感、评估、评价、态度、情绪。情感分析、观点挖掘、观点萃取、情感挖掘、主观性分析、影响分析、情绪分析、评论分析等都归属于情感分析这一大类。</h6><h3 id="1-1-情感分析的应用"><a href="#1-1-情感分析的应用" class="headerlink" title="1.1 情感分析的应用"></a>1.1 情感分析的应用</h3><p>在生活中，我们寻求他人观点用以：</p><ul><li>个人对商品的选择与购买</li><li>商家了解产品或服务的评价</li><li>政治选举</li></ul><p>为什么要使用情感分析：</p><ul><li>网络上用于发表观点的不同的网站众多</li><li>观点可能隐藏在长篇大论之中</li><li>独自筛选总结困难，因为需要自动的情感分析系统</li></ul><p><strong>意见分析器</strong>（<em>Opinion</em> <em>Parser</em>）</p><h3 id="1-2-情感分析研究"><a href="#1-2-情感分析研究" class="headerlink" title="1.2 情感分析研究"></a>1.2 情感分析研究</h3><h4 id="1-2-1-分析的不同层次"><a href="#1-2-1-分析的不同层次" class="headerlink" title="1.2.1 分析的不同层次"></a>1.2.1 分析的不同层次</h4><p>三个主要层次：</p><ul><li>文档层次：从文章整体角度考虑情感倾向。不适用于评价或比较多个物体的文章。</li><li>句子层次：判断句子的观点（积极、消极、中立），类似于主观性分类。</li><li>实体与方面层次：从某一实体或者某实体的某方面进行分析。</li></ul><p>对于观点的分类：</p><ul><li>普通评论</li><li>比较性评论</li></ul><h4 id="1-2-2-情感词典及相关问题"><a href="#1-2-2-情感词典及相关问题" class="headerlink" title="1.2.2 情感词典及相关问题"></a>1.2.2 情感词典及相关问题</h4><p>尽管情感词汇对于情感分析来说是十分重要的，但是只是使用它们是不够充分的：</p><ul><li>有些词汇不能明确的区分为积极或消极；</li><li>有些句子虽然包含情感词汇，但是只是客观陈述，不表达情感；</li><li>有些句子虽然不包含情感词汇，但是表达出了某些情感；</li><li>存在反语。</li></ul><h4 id="1-2-3-自然语言处理问题"><a href="#1-2-3-自然语言处理问题" class="headerlink" title="1.2.3  自然语言处理问题"></a>1.2.3  自然语言处理问题</h4><p>​        情感分析涉及到自然语言处理的各个方面，许多NLP中的未解问题使得情感分析更加困难。但是由于情感分析不需要完整的了解句子的语义，只需要理解其中的某些方面（观点的积极与消极等），因而也为NLP的研究者们提供了一定的平台。</p><h3 id="1-3-垃圾观点检测"><a href="#1-3-垃圾观点检测" class="headerlink" title="1.3 垃圾观点检测"></a>1.3 垃圾观点检测</h3><p>​        由于人们可以匿名发表一些评论，虽然因此可能会出现一些非常有价值的观点，但是这也导致了恶意评论掩盖真实评论的情况。如果我们要发现这些垃圾观点，就不仅需要自然语言处理，也需要对于数据的挖掘。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h6 id="情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。"><a href="#情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。" class="headerlink" title="情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。"></a>情感分析的问题：情感分析问题的结构化，利用框架的方式将各类问题联系起来。由于情感分析研究的这类评论带有强大主观性，因此若想拥有实际的应用性则需要从许多不同的用户那里搜集大量的相关评论。相比于较易分析的产品评价，社会政策的讨论往往较为复杂、存在更多的反语和讽刺。</h6><h3 id="2-1-问题定义"><a href="#2-1-问题定义" class="headerlink" title="2.1 问题定义"></a>2.1 问题定义</h3><h4 id="2-1-1-观点定义"><a href="#2-1-1-观点定义" class="headerlink" title="2.1.1 观点定义"></a>2.1.1 观点定义</h4><p>将一条 <em>opinion</em> 分为四个部分：（<em>g ,s ,h ,t</em> ）</p><ul><li>g —— target 对象</li><li>s —— sentiment 情感</li><li>h —— holder 评论者</li><li>t —— time 时间</li></ul><p>如果进一步考虑，则可以将观点的对象这一实体分为不同的方面考虑，继而则形成了五元组：（<em>e ,a ,s ,h ,t</em> ）,其中：</p><ul><li>e —— entity 实体</li><li>a —— aspect 方面</li></ul><h4 id="2-1-2-情感分析任务"><a href="#2-1-2-情感分析任务" class="headerlink" title="2.1.2 情感分析任务"></a>2.1.2 情感分析任务</h4><p>主要分为以下几个任务：</p><p>​        情感分析的目的、实体分类和表达的定义、各方面分类和表达的定义、显性方面表达的定义、隐形方面表达的定义、实体模型、观点文献的模型</p><p>总结得到六个任务：</p><p>Task1：提取整体并分类</p><p>Task2：提取方面并分类</p><p>Task3：提取观点持有者并分类</p><p>Task4：提取时间并规范化</p><p>Task5：提取情感并分类</p><p>Task6：观点的五部分 <em>(e ,a ,s ,h ,t  )</em>的综合</p><h4 id="2-2-观点总结"><a href="#2-2-观点总结" class="headerlink" title="2.2 观点总结"></a>2.2 观点总结</h4><p>​        由于我们往往需要获取不只一个用户的观点，而是需要统计大量的评论，这使得我们需要对于它们进行总结，需要兼顾质量和数量。</p><h4 id="2-3-观点的不同类型"><a href="#2-3-观点的不同类型" class="headerlink" title="2.3 观点的不同类型"></a>2.3 观点的不同类型</h4><ul><li><p>一般性和比较性观点</p></li><li><p>明确性和暗示性观点</p></li></ul><h4 id="2-4-主观性和情绪"><a href="#2-4-主观性和情绪" class="headerlink" title="2.4 主观性和情绪"></a>2.4 主观性和情绪</h4><p>主观性评论与客观性评论：</p><ul><li>主观评论往往表现了个人的一些观点和感觉，客观则是包含一些事实信息。</li><li>主观评论可能不包含任何感情，客观语句也可能暗示一些情感或观点。</li></ul><p>情感（emotion）：</p><ul><li>主观性的感觉或想法</li><li>五个情感等级<ol><li>emotional negative </li><li>rational negative</li><li>neutral</li><li>rational positive</li><li>emotional positive</li></ol></li></ul><h4 id="2-5-作者及读者立场"><a href="#2-5-作者及读者立场" class="headerlink" title="2.5 作者及读者立场"></a>2.5 作者及读者立场</h4><p>​        不同层次立场的人看待相同的问题可能会产生不同的乃至相反的想法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统2</title>
    <link href="/2020/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2/"/>
    <url>/2020/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F2/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统2——关系数据库系统。</p><a id="more"></a><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h6 id="关系模型是由-E-F-Codd-于-1970-年提出的。"><a href="#关系模型是由-E-F-Codd-于-1970-年提出的。" class="headerlink" title="关系模型是由 E.F.Codd 于 1970 年提出的。"></a>关系模型是由 E.F.Codd 于 1970 年提出的。</h6><h4 id="关系模型的组成要素"><a href="#关系模型的组成要素" class="headerlink" title="关系模型的组成要素"></a>关系模型的组成要素</h4><h5 id="三个组成要素"><a href="#三个组成要素" class="headerlink" title="三个组成要素"></a>三个组成要素</h5><ul><li>关系数据结构<ul><li>建立在<strong>集合代数</strong>的基础上</li></ul></li><li>完整性约束<ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li><li>关系运算<ul><li>关系代数 —— 基于集合的运算 —— 基于关系代数设计的数据库语言（ISBL）</li><li>关系演算<ul><li>元组演算 —— 基于逻辑的运算 —— 基于元组演算设计的数据库语言（QUEL）</li><li>域演算 —— 基于示例的运算 —— 基于域演算设计的数据库语言（eg：QBE）</li></ul></li></ul></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p><strong>基本概念</strong></p><ul><li><p><strong>关系</strong> —— 表</p><ul><li>数据集合</li><li>属性不可再分（关系第一范式）</li></ul></li><li><p><strong>元组</strong>（记录） —— 行 </p><ul><li>任意两个元组不可重复（集合性质）<ul><li>但是很多产品没有遵守这一性质</li></ul></li></ul></li><li><p><strong>属性</strong>（字段、数据项）—— 列</p><ul><li>同质性：每一列中的分量是同类型的，来自同一个域</li><li>不同的列可能出自同一个域</li></ul></li><li><p><strong>域</strong> —— 列的取值范围</p><ul><li>一组具有相同数据类型的值的集合</li></ul></li><li><p><strong>关系模式</strong> —— 大概相当于表头（并不）</p><p>形式：$R(U,D,DOM,I,F)$</p><p>简记为：$R(U)$，若 $U=\{A_1,A_2,…,A_n\}$，也可写为 $R(A_1,A_2,…,A_n)$，n 称为关系的目（或者度）。</p></li><li><p><strong>关系实例</strong>：关系模式在给定时刻的一个快照。时某一时刻现实世界状态的真实反映。</p></li><li><p><strong>关系数据库模式&amp;关系数据库实例</strong></p></li></ul></li><li><p><strong>补充概念</strong></p><ul><li><p><strong>基数</strong>：集合中元素的个数</p></li><li><p><strong>笛卡尔积</strong>：由n个域形成的所有可能的n元组的集合</p><p>$D_1 \times D_2 \times … \times D_n = \{(d_1,d_2,…,d_n) | d_i \in D_i, i = 1,2,…,n \}$</p><p>笛卡尔积的每一个元素成为一个n-元组。</p></li><li><p><strong>分量</strong>：元组中的每一个值叫做一个分量</p></li></ul></li></ul><h4 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h4><h5 id="各种码的概念"><a href="#各种码的概念" class="headerlink" title="各种码的概念"></a>各种码的概念</h5><ul><li><p><strong>超码</strong>：一个或多个属性的集合，这些属性的组合可以<strong>唯一标识一个元组</strong>的。</p></li><li><p><strong>候选码</strong>：最小的超码，一个关系模式中可能不止一个候选码。</p></li><li><strong>主码</strong>：被选定用来区分不同元组的候选码，一个关系模式只有一个。</li><li><strong>主属性</strong>：主码中的属性。</li><li><strong>外码</strong>：关系模式$R_1$的属性中包含另一个关系模式$R_2$中的主码，这个属性集合被称为参照$R_2$的外码。</li></ul><h5 id="关系数据模型的完整性约束"><a href="#关系数据模型的完整性约束" class="headerlink" title="关系数据模型的完整性约束"></a>关系数据模型的完整性约束</h5><ul><li><strong>实体完整性约束</strong>：主码属性值不能为空值。<ul><li>空值：不知道、不存在或者无意义的值。</li></ul></li><li><strong>参照完整性约束</strong>：如果关系$R_1$的外码$F_k$与关系$R_2$的主码$P_k$相对应，则$R_1$中的每一个元组的$F_k$值要等于$R_2$中某个元组的$P_k$值或者为空值。</li><li><strong>用户定义的完整性约束</strong>：用户针对具体的应用程序定义的完整性约束条件。</li></ul><p>（语义完整性约束和函数依赖？）</p><h5 id="DBMS对于完整性的支持"><a href="#DBMS对于完整性的支持" class="headerlink" title="DBMS对于完整性的支持"></a>DBMS对于完整性的支持</h5><ul><li>实体完整性&amp;参照完整性是由DBMS系统字段支持的</li><li>DBMS系统通常会提供以下机制：<ul><li>使得用户可以自行定义有关的完整性约束条件。</li><li>在发生更新时自动检验。</li></ul></li></ul><h4 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h4><h5 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h5><h6 id="关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。"><a href="#关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。" class="headerlink" title="关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。"></a>关系代数是一种过程化查询语言。关系代数操作以一个或多个关系作为输入，结果得到一个新的关系。</h6><p><strong>关系代数运算</strong></p><ul><li>六种基本运算：选择、投影、并、差、笛卡尔积、重命名。</li><li>其他运算：交、连接、除。（可用基本运算组合定义）</li></ul><p><strong>相容性</strong>：关系 R 与关系 S 存在相容性，当且仅当：</p><ol><li>关系 R 与关系 S 的属性数目相同。</li><li>R 中与 S 中相对应位置的属性的域相同。</li></ol><h6 id="并、差、交运算需满足相容性"><a href="#并、差、交运算需满足相容性" class="headerlink" title="并、差、交运算需满足相容性"></a><em>并、差、交运算需满足相容性</em></h6><p><strong>关系代数基本运算</strong></p><ul><li><strong>并</strong>： $R\cup S = \{t | t \in R \wedge t\in S\}$，其中 $t$ 是元组。</li><li><strong>差</strong>：$R-S = \{t \in R \wedge t\notin S\}$</li><li><strong>笛卡尔积（积）</strong>：$R \times S = \{<a_1,a_2,...,a_n,b_1,...,b_m> | <a_1,a_2,...,a_n>\in R \wedge <b_1,...,b_m> \in S \}$</b_1,...,b_m></a_1,a_2,...,a_n></a_1,a_2,...,a_n,b_1,...,b_m></li><li><strong>选择</strong>：$\sigma_{con}(R)=\{t | t\in R\wedge con(t)\}$<ul><li>$con$为选择谓词，运算符优先次序为：$括号; \theta; \lnot ; \wedge; \vee$ </li></ul></li><li><strong>投影</strong>：$\Pi_{A_1,A_2,…A_k}(R) = \{<t[A_1],t[A_2],...,t[A_k]> | t\in R\}$<ul><li>注意去除重复元组</li></ul></t[A_1],t[A_2],...,t[A_k]></li><li><strong>更名</strong>：$\rho_S (R)$ 或者 $\rho_{S(A_1,…,A_n)}(R)$</li></ul><p><strong>附加运算</strong></p><h6 id="附加运算不增加关系代数的表达能力，但是可以简化常用查询。"><a href="#附加运算不增加关系代数的表达能力，但是可以简化常用查询。" class="headerlink" title="附加运算不增加关系代数的表达能力，但是可以简化常用查询。"></a>附加运算不增加关系代数的表达能力，但是可以简化常用查询。</h6><ul><li><strong>交</strong>：$R \cap  S = \{t |t\in R and t \in S\}$</li><li><strong>连接</strong><ul><li>$\theta$ <strong>连接</strong>：大概是有连接条件的连接</li><li><strong>等值连接</strong>：$\theta$ 为等号的$\theta$ 连接</li><li><strong>自然连接</strong>（$\bowtie$）：要求进行笛卡尔积的两个关系在所有相同属性上的值一致</li></ul></li><li><strong>赋值</strong>：只能赋给临时关系变量，不能增加关系运算的表达能力</li><li><strong>外连接</strong>：（左外连接&amp;右外连接&amp;全外连接）左外是以左边为准，没法匹配的用null填充右边属性。</li><li><strong>除</strong>：$R \div S = \{t | t \in \Pi_z(R) \wedge \forall u \in S (tu \in R) \}$</li></ul><p><strong>其他扩展运算</strong></p><h6 id="可以实现不能有基本的关系代数运算来表达的查询"><a href="#可以实现不能有基本的关系代数运算来表达的查询" class="headerlink" title="可以实现不能有基本的关系代数运算来表达的查询"></a>可以实现不能有基本的关系代数运算来表达的查询</h6><ul><li>广义投影：在投影中使用算术运算和字符</li><li>聚集</li></ul><h5 id="关系演算——元组演算"><a href="#关系演算——元组演算" class="headerlink" title="关系演算——元组演算"></a>关系演算——元组演算</h5><h6 id="非过程化的查询语言，只需要描述所需信息而不需要给出获取过程"><a href="#非过程化的查询语言，只需要描述所需信息而不需要给出获取过程" class="headerlink" title="非过程化的查询语言，只需要描述所需信息而不需要给出获取过程"></a>非过程化的查询语言，只需要描述所需信息而不需要给出获取过程</h6><ul><li><p>表达式：$\{t | P(T)\}$</p><ul><li>所有使得公式P为真的元组t的集合</li></ul></li><li><p>公式P由原子公式构成</p><ul><li>$s \in R; s[x] \Theta u[y]; s[x] \Theta C.$</li></ul></li></ul><h5 id="关系演算——域演算"><a href="#关系演算——域演算" class="headerlink" title="关系演算——域演算"></a>关系演算——域演算</h5><h6 id="使用从属性域中取值的域变量，而不是整个元组的值"><a href="#使用从属性域中取值的域变量，而不是整个元组的值" class="headerlink" title="使用从属性域中取值的域变量，而不是整个元组的值"></a>使用从属性域中取值的域变量，而不是整个元组的值</h6><ul><li>形式化定义：$\{<x_1,...,x_n>|P(x_1,…,x_n)\}$<ul><li>其中$x_1,…,x_n$分别是域变量</li><li>P由原子公式构成</li><li>查询结果时是有包含$<x_1,...,x_n>$且使$P(x_1,…,x_n)$为真的元组</x_1,...,x_n></li></ul></x_1,...,x_n></li></ul><h5 id="关系运算的安全性"><a href="#关系运算的安全性" class="headerlink" title="关系运算的安全性"></a>关系运算的安全性</h5><ul><li>安全关系运算系统：如果一个关系运算系统不产生不限关系和无穷验证则是安全的</li><li>关系代数系统是安全的</li><li>元组演算和域演算是不安全的<ul><li>引入元组关系公式的域的概念，对关系演算进行限制</li></ul></li></ul><h5 id="三者等价性"><a href="#三者等价性" class="headerlink" title="三者等价性"></a>三者等价性</h5><p>下述三者等价：</p><ul><li>基本关系代数</li><li>限制在安全范围内的元组关系演算</li><li>限制在安全范围内的域关系演算</li></ul><h6 id="本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）"><a href="#本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）" class="headerlink" title="本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）"></a>本章重点：关系、属性、元组、码等关系数据结构基本概念；关系代数；完整性约束（实体完整性、参照完整性、用户定义完整性）</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统1</title>
    <link href="/2020/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1/"/>
    <url>/2020/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1/</url>
    
    <content type="html"><![CDATA[<p>​        数据库系统1——基本知识与关系模型。</p><p>​        参考了中国人民大学的 Mooc 和战神的 Spoc 以及教材。</p><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h4 id="一些名词："><a href="#一些名词：" class="headerlink" title="一些名词："></a><strong>一些名词：</strong></h4><ul><li><p>数据（Data）:描述事物的符号记录。数据与其语义不可分。</p></li><li><p>数据库 （DB）：长期储存在计算机内的、有组织的、可共享的、相互关联的数据的集合。</p></li><li><p>数据库管理系统 （DBMS）：管理数据库的软件系统。</p></li><li><p>SQL（结构化查询语言）：用于管理关系数据库管理系统，或在关系流数据管理系统（RDSMS）中进行流处理。</p></li><li><p>数据库应用程序 （DBAP）</p></li><li><p>数据库系统（DBS）：指在计算机系统中引入数据库后构成的系统，一般由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员和用户构成。</p></li></ul><h4 id="数据库管理技术发展过程"><a href="#数据库管理技术发展过程" class="headerlink" title="数据库管理技术发展过程"></a>数据库管理技术发展过程</h4><p>​    三个阶段：人工管理阶段 $\rightarrow$ 文件系统阶段 $\rightarrow$ 数据库系统阶段</p><p>​    阶段对比如下表（来自人大的Mooc）</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F1.assets/image-20200304164606749.png" srcset="/img/loading.gif" alt="image-20200304164606749"></p><h4 id="数据库管理系统功能"><a href="#数据库管理系统功能" class="headerlink" title="数据库管理系统功能"></a>数据库管理系统功能</h4><h5 id="从用户角度考虑"><a href="#从用户角度考虑" class="headerlink" title="从用户角度考虑"></a>从用户角度考虑</h5><ul><li>数据库定义：提供 <strong>数据定义语言（DDL）</strong> 以定义数据格式。</li><li>数据库操纵：提供 <strong>数据操纵语言（DML）</strong>进行数据的<strong>增、删、改、(查)</strong> 操作。</li><li>数据库控制：提供 <strong>数据控制语言（DCL）</strong> 让管理员对于数据的使用进行控制。</li><li>数据库维护：转储、恢复、重组、性能检测、分析等。</li></ul><p><em>DDL、DML、DCL 联合起来就是 SQL语言。（不过这句话我有点疑惑…）</em></p><h5 id="从系统实现角度考虑"><a href="#从系统实现角度考虑" class="headerlink" title="从系统实现角度考虑"></a>从系统实现角度考虑</h5><ul><li>语言编译器：将用数据库语言书写的内容翻译成DBMS的可执行命令。</li><li>查询优化（执行引擎）与查询实现（基本命令的不同执行算法）</li><li>数据存取索引：提供数据在磁盘、磁带等上的高效存取手段。</li><li>通信控制：提供网络环境下的数据库操作与数据传输手段。</li><li>事务管理：提供高可靠性并避免并发操作错误的手段。</li><li>故障恢复：是数据库自动恢复到故障发生前的正常状态的手段。</li><li>安全性控制：提供合法性检验，避免非授权用户非法访问的手段。</li><li>完整性控制：提供数据集数据操作正确性检查的手段。</li><li>应用程序接口（API）：提供应用程序使用DBMS特定功能的手段。</li><li>数据库数据装载、重组等实用程序</li><li>数据库性能分析</li></ul><h2 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h2><h4 id="数据抽象"><a href="#数据抽象" class="headerlink" title="数据抽象"></a>数据抽象</h4><p>三层抽象：（不同的 Mooc 称呼不太一样233）</p><ul><li>视图层（外部层次）</li><li>逻辑层（全局层次）</li><li>物理层（内部层次）</li></ul><h4 id="模式与实例"><a href="#模式与实例" class="headerlink" title="模式与实例"></a>模式与实例</h4><p>​    模式——对于数据可逻辑结构和特征的描述、不涉及具体的值且相对稳定。</p><p>​    实例——模式的具体值，是数据库在将某一时刻的状态、随数据库的数据更新而改变。</p><h4 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h4><ol><li>逻辑独立性：用户应用程序与数据库的逻辑结构相互独立。</li><li>物理独立性：用户的应用程序与数据库中数据的的物理存储相互独立。</li></ol><p><em>数据独立性是由DBMS的两层映像保证的。</em></p><h4 id="三级模式与两层映像"><a href="#三级模式与两层映像" class="headerlink" title="三级模式与两层映像"></a>三级模式与两层映像</h4><h5 id="三级模式"><a href="#三级模式" class="headerlink" title="三级模式"></a><strong>三级模式</strong></h5><p>​    <em>三级模式与之前的三层抽象相对应</em></p><ul><li>外模式（子模式）—— 局部角度</li><li>逻辑模式 —— 全局角度</li><li>内模式（物理模式、存储模式）</li></ul><h5 id="两层映像"><a href="#两层映像" class="headerlink" title="两层映像"></a><strong>两层映像</strong></h5><p>​    <em>三个层次的联系和转换，由DBMS内部提供</em></p><ul><li>外模式 - 逻辑模式（E-C）映像<ul><li>映像定义通常包含在各外模式描述中。</li><li>保证了数据的逻辑独立性：在逻辑模式发生改变时，数据库管理员可以通过修改E-C映像是的外模式保持不变，从而使得依据外模式编写的应用程序无需修改。</li></ul></li><li>逻辑模式 - 内模式 （C-I）映像<ul><li>映像定义通常包含各逻辑模式描述中。</li><li>保证了数据的物理独立性：物理存储模式发生变化时，通过修改映像使得逻辑模式不变，外模式不变，应用程序不变。</li></ul></li></ul><p>作用：</p><ul><li>保证了应用程序的稳定性，减少了应用程序的维护和修改。</li><li>使得数据定义和描述从应用程序中分离开。</li><li>数据的存取由DBMS管理，简化了应用程序的编制。</li></ul><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h6 id="这部分主要参考了人大的mooc"><a href="#这部分主要参考了人大的mooc" class="headerlink" title="这部分主要参考了人大的mooc"></a>这部分主要参考了人大的mooc</h6><h4 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h4><ol><li><p>概念模型（信息模型）—— 按用户观点考虑、用于数据库设计</p><ul><li>eg：实体—联系模型（E-R模型）</li></ul></li><li>逻辑模型和物理模型<ol><li>逻辑模型 —— 按照计算机系统的观点考虑、用于DBMS的实现<ul><li>网状模型、层次模型</li><li>关系模型</li><li>面向对象（O-O）数据模型、对象关系（O-R）数据模型</li><li>半结构化数据模型</li></ul></li><li>物理模型 —— 对于数据最底层的抽象、描述数据在系统内的表示和存取方法。</li></ol></li></ol><h4 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h4><ul><li>数据结构 —— 描述系统的静态特性</li><li>数据操作 —— 描述系统的动态特性</li><li>完整性约束</li></ul><h4 id="层次模型、网状模型与关系模型"><a href="#层次模型、网状模型与关系模型" class="headerlink" title="层次模型、网状模型与关系模型"></a>层次模型、网状模型与关系模型</h4><h5 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h5><p>满足以下两个条件的基本层次联系的集合为<strong>层次模型</strong></p><ul><li>有且只有一个节点没有父亲节点——这个节点叫做根节点</li><li>根节点以外的节点有且只有一个父亲节点</li></ul><h6 id="树状哒"><a href="#树状哒" class="headerlink" title="树状哒"></a>树状哒</h6><p><strong>数据结构</strong>——满足下列条件的树</p><ul><li>每个节点代表一个实体</li><li>边表示对象之间的联系</li></ul><p><strong>特点</strong></p><ul><li>只能处理一对多的实体联系（父节点唯一）</li><li>任何记录值都只有按路径查看时才显示全部意义</li><li>没有一个子女记录纸可以推理父亲记录值单独存在</li></ul><p><strong>层次模型的完整性约束</strong></p><ul><li>无相应的父亲节点值就不能插入子女节点值</li><li>删除父亲节点值时，子女节点值也要删除</li><li>更新时，应更新所有相应记录，以保证数据一致性</li></ul><p><strong>优缺点</strong></p><ul><li><p>优点：简单、（对于一对多而言）描述自然直观、易于理解、完整性支持良好</p></li><li><p>缺点：多对多联系表示不自然，插入删除限制多，查询子女节点必须通过父亲节点，面向过程</p></li></ul><h6 id="eg：IMS数据库管理系统（1968）"><a href="#eg：IMS数据库管理系统（1968）" class="headerlink" title="eg：IMS数据库管理系统（1968）"></a>eg：IMS数据库管理系统（1968）</h6><h5 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h5><p><strong>数据结构</strong>——满足下列条件的图</p><ul><li>每个节点是一个对象记录</li><li>边表示对象之间的联系</li><li>允许多个节点无父亲节点</li><li>允许节点有多个父亲节点</li><li>允许两个节点之间有多种联系</li></ul><h6 id="图状哒"><a href="#图状哒" class="headerlink" title="图状哒"></a>图状哒</h6><p><strong>完整性约束</strong></p><ul><li>允许插入父亲节点值未确定的子女节点值</li><li>允许只删除父亲节点值</li><li>一些具体系统提供了一些完整性约束</li></ul><p><strong>优缺点</strong></p><ul><li>优点：更加直观，性能良好、存取效率高</li><li>缺点：结构复杂，不利于最终用户掌握；DDL、DML语言复杂，不易于用户使用；面型过程</li></ul><h6 id="eg：最早的网状数据库管理系统IDS（1964）"><a href="#eg：最早的网状数据库管理系统IDS（1964）" class="headerlink" title="eg：最早的网状数据库管理系统IDS（1964）"></a>eg：最早的网状数据库管理系统IDS（1964）</h6><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据——信息载体</li><li><p>数据库——数据集合</p></li><li><p>数据库管理系统——软件系统</p></li><li>数据库系统</li></ul><h6 id="本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。"><a href="#本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。" class="headerlink" title="本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。"></a>本章重点：掌握数据库系统的基本概念，及与文件系统相比较的优势；掌握数据抽象中三级模式、两级映像、数据独立性等概念。</h6>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（3）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第五章-伪随机置换（分组加密）的实际构建"><a href="#第五章-伪随机置换（分组加密）的实际构建" class="headerlink" title="第五章 伪随机置换（分组加密）的实际构建"></a>第五章 伪随机置换（分组加密）的实际构建</h2><h6 id="密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。"><a href="#密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。" class="headerlink" title="密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。"></a>密码学第三次作业所需内容，密码学好难qaq，不想写作业。。。</h6><h3 id="5-1-代替——置换网络"><a href="#5-1-代替——置换网络" class="headerlink" title="5.1 代替——置换网络"></a>5.1 代替——置换网络</h3><p><strong>S盒</strong>（替换盒）：对称密钥加密算法执行替换计算的基本结构。在块密码中，通常被用于模糊密钥与密文之间的关系（香农的混淆理论）</p><h6 id="通常，S-Box接受特定数量的输入比特-m-，并将其转换为特定数量的输出比特-n-，其中-n-不一定等于-m-。一个-m-n-的S-Box可以通过包含-2-m-条目，每条目-n-比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。"><a href="#通常，S-Box接受特定数量的输入比特-m-，并将其转换为特定数量的输出比特-n-，其中-n-不一定等于-m-。一个-m-n-的S-Box可以通过包含-2-m-条目，每条目-n-比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。" class="headerlink" title="通常，S-Box接受特定数量的输入比特$m$，并将其转换为特定数量的输出比特$n$，其中$n$不一定等于$m$。一个$m*n$的S-Box可以通过包含$2^m$条目，每条目$n$比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。"></a>通常，S-Box接受特定数量的输入比特$m$，并将其转换为特定数量的输出比特$n$，其中$n$不一定等于$m$。一个$m*n$的S-Box可以通过包含$2^m$条目，每条目$n$比特的查找表实现。DES和AES的S盒是固定的，也有一些加密算法的S盒是基于密钥动态生成的，比如Blowfish和双鱼算法。</h6><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140146509.png" srcset="/img/loading.gif" alt="image-20200302140146509"></p><p><strong>P盒</strong>（置换盒）： 是一个透过置换和转置[替换盒（S-boxes）输入进行位元洗牌的方法，在转置的过程中保持一定程度的<a href="https://zh.wikipedia.org/wiki/混淆與擴散" target="_blank" rel="noopener">扩散</a>。 </p><p>置换盒通常分为三类：</p><ul><li>压缩性的——输出位元数比输入少</li><li>扩张性的——输出位元数比输入多</li><li>平直性的——输出位元数等于输入位元数</li></ul><p>其中只有平直性的置换盒是可逆的。</p><p><strong>代替置换网络（SP）</strong>：</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140221062.png" srcset="/img/loading.gif" alt="image-20200302140221062"></p><p><strong>设计原则</strong>：</p><ul><li>S盒的可逆性：在代替置换网络中，S盒必须是可逆的（即必须是单射和满射函数），否则分组函数不能成为一个置换</li><li>雪崩效应：任何分组密码的一个重要特性就是输入的微小改变必然会导致输出的巨大改变，否则两个相似输入所生成的分组密码看起来就不是独立的了。因此，输入的单个比特的变化会影响每一个比特。<ul><li>S盒的设计要使得改变S盒输入的单个比特就能改变S盒输出的至少两个比特</li><li>混合置换的设计要使得任何给定的S盒的输出比特都被传递到下一轮中不同的S盒中</li></ul></li></ul><p><strong>代替置换网络的安全性</strong>：</p><p><strong>对轮数较少的代替转换网络的攻击</strong>：</p><p><strong>攻击三轮代替-置换网络</strong>：</p><h3 id="5-2-Feistel网络"><a href="#5-2-Feistel网络" class="headerlink" title="5.2 Feistel网络"></a>5.2 Feistel网络</h3><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140312519.png" srcset="/img/loading.gif" alt="image-20200302140312519"></p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%883%EF%BC%89.assets/image-20200302140333394.png" srcset="/img/loading.gif" alt="image-20200302140333394"></p><h3 id="5-3-DES——数据加密标准"><a href="#5-3-DES——数据加密标准" class="headerlink" title="5.3 DES——数据加密标准"></a>5.3 DES——数据加密标准</h3><h3 id="5-4-增加分组密码的密钥长度"><a href="#5-4-增加分组密码的密钥长度" class="headerlink" title="5.4 增加分组密码的密钥长度"></a>5.4 增加分组密码的密钥长度</h3><h3 id="5-5-AES——高级加密标准"><a href="#5-5-AES——高级加密标准" class="headerlink" title="5.5 AES——高级加密标准"></a>5.5 AES——高级加密标准</h3><h3 id="5-6-差分密码盒线性密码分析简介"><a href="#5-6-差分密码盒线性密码分析简介" class="headerlink" title="5.6 差分密码盒线性密码分析简介"></a>5.6 差分密码盒线性密码分析简介</h3><h2 id="第六章-伪随机对象的理论构造"><a href="#第六章-伪随机对象的理论构造" class="headerlink" title="第六章 伪随机对象的理论构造"></a>第六章 伪随机对象的理论构造</h2><h3 id="6-1-单向函数"><a href="#6-1-单向函数" class="headerlink" title="6.1 单向函数"></a>6.1 单向函数</h3><h5 id="单向函数的定义："><a href="#单向函数的定义：" class="headerlink" title="单向函数的定义："></a>单向函数的定义：</h5><ul><li>令$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$为一个函数，$A$为任意算法，$n$为任意安全参数值：<ul><li>求逆实验$Invert_{A.f}(n)$<ul><li>选择输入$x\leftarrow\{0,1\}^n$，计算$y:=f(x)$</li><li>$1^n$和$y$值作为$A$的输入，输出为$x’$</li><li>如果$f(x’)=y$，那么定义该实验输出为1，否则为0</li></ul></li></ul></li><li><strong>定义</strong>：如果一个函数$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$满足以下两个条件，那么它是单向函数：<ul><li>（易于计算）存在多项式时间算法$M_f$来计算$f$,即对于所有的$x$，有$M_f(x)$</li><li>（反向求逆十分困难）对任意概率多项式时间算法$A$，存在一个可忽略函数$negl$，满足：$Pr[Invert_{A,f}(n)=1]\leqslant negl(n)$<ul><li>也可表示为：$Pr_{x\leftarrow\{0,1\}^n}[A(f(x))∈f^{-1}(f(x))] \leqslant negl(n) $</li></ul></li></ul></li></ul><h5 id="单向置换："><a href="#单向置换：" class="headerlink" title="单向置换："></a>单向置换：</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（2）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第三章-对称密钥加密及为随机性"><a href="#第三章-对称密钥加密及为随机性" class="headerlink" title="第三章 对称密钥加密及为随机性"></a>第三章 对称密钥加密及为随机性</h2><h3 id="3-1密码学的计算方法"><a href="#3-1密码学的计算方法" class="headerlink" title="3.1密码学的计算方法"></a>3.1密码学的计算方法</h3><h4 id="信息理论安全与计算安全"><a href="#信息理论安全与计算安全" class="headerlink" title="信息理论安全与计算安全"></a>信息理论安全与计算安全</h4><ul><li>信息理论安全：完善保密加密</li><li>计算安全：使用具体方法和渐进方法来定义：<ul><li>具体方法：如果每个运行时间最多为$t$的敌手以最多为$\varepsilon$的概率成功公婆该方案，则称这个方案为$(t,\varepsilon)$安全</li><li>渐进方法：如果每个PPT（多项式时间）敌手以可忽略的概率成功攻破一个方案，那么该方案是安全的<ul><li>注：在任何加密方案中，密钥空间必须足够大，以至于敌手不能变量，或者说，密钥空间的时间规模必须为安全参数的超多项式</li></ul></li></ul></li></ul><h4 id="有效的算法与可忽略的成功概率"><a href="#有效的算法与可忽略的成功概率" class="headerlink" title="有效的算法与可忽略的成功概率"></a>有效的算法与可忽略的成功概率</h4><ul><li><strong>有效计算</strong>：指能够在“概率多项式时间”（PPT）内执行的计算</li><li><strong>可忽略的成功概率</strong>：如果对于每一个多项式$p(.)$，存在一个$N$，使得所有的整数$n&gt;N$，都满足$f(n)&lt;1/p(n)$，则函数$f$是可忽略的</li></ul><h4 id="如何证明某个密码构造是安全的"><a href="#如何证明某个密码构造是安全的" class="headerlink" title="如何证明某个密码构造是安全的"></a>如何证明某个密码构造是安全的</h4><ol><li>指定PPT敌手$A$攻击，并将成功的概率表示为$\varepsilon(n)$</li><li>构造一个叫做”规约“的有效算法$A~’$（区分器？）,该算法将敌手$A$作为子程序来使用，试图解决难题$X$。<img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%882%EF%BC%89.assets/image-20200302140115640.png" srcset="/img/loading.gif" alt="image-20200302140115640"></li><li>如果能成功攻破，那么说明该区分器可以区分这个加密算法所使用的伪随机生成器</li><li>但是根据伪随机生成器的定义，不可被区分</li><li>所以矛盾，证明该算法安全</li></ol><h3 id="3-2-定义计算安全的加密"><a href="#3-2-定义计算安全的加密" class="headerlink" title="3.2 定义计算安全的加密"></a>3.2 定义计算安全的加密</h3><h4 id="窃听者存在情况下的不可区分性"><a href="#窃听者存在情况下的不可区分性" class="headerlink" title="窃听者存在情况下的不可区分性"></a>窃听者存在情况下的不可区分性</h4><p>​    窃听者不可区分实验$PrivK^{eav}_{A,\Pi}(n)$:</p><ul><li>给定输入$1^n$给敌手$A$，$A$输出一对长度相等的消息$m_0$,$m_1$。</li><li>运行$Gen(1^n)$生成以个密钥k，选择一个随机比特$b$，$b∈\{0,1\}$。计算出密文$c=Enc_k(m_b)$，并且给$A$。把$c$叫做挑战密文。</li><li>$A$输出一个比特$b’$</li><li>如果$b=b’$输出1，反之输出0.</li></ul><h5 id="定义：如果对于所有的概率多项式事件敌手-A-存在一个可忽略函数-negl-使得：-Pr-PrivK-eav-A-Pi-lt-1-2-negl-n-则一个对称密钥加密方案-Pi-Gen-Enc-Dec-具备在窃听者存在的情况下不可区分的加密。"><a href="#定义：如果对于所有的概率多项式事件敌手-A-存在一个可忽略函数-negl-使得：-Pr-PrivK-eav-A-Pi-lt-1-2-negl-n-则一个对称密钥加密方案-Pi-Gen-Enc-Dec-具备在窃听者存在的情况下不可区分的加密。" class="headerlink" title="定义：如果对于所有的概率多项式事件敌手$A$,存在一个可忽略函数$negl$使得：$Pr[PrivK^{eav}_{A,\Pi}&lt;= 1/2 +negl(n)$,则一个对称密钥加密方案$\Pi=(Gen,Enc,Dec)$具备在窃听者存在的情况下不可区分的加密。"></a>定义：如果对于所有的概率多项式事件敌手$A$,存在一个可忽略函数$negl$使得：$Pr[PrivK^{eav}_{A,\Pi}&lt;= 1/2 +negl(n)$,则一个对称密钥加密方案$\Pi=(Gen,Enc,Dec)$具备在窃听者存在的情况下不可区分的加密。</h5><h5 id="等价公式：-Pr-output-PrivK-eav-A-Pi-n-0-1-Pr-output-PrivK-eav-A-Pi-n-1-1-lt-negl-n"><a href="#等价公式：-Pr-output-PrivK-eav-A-Pi-n-0-1-Pr-output-PrivK-eav-A-Pi-n-1-1-lt-negl-n" class="headerlink" title="等价公式：$|Pr[output(PrivK^{eav}_{A,\Pi}(n,0))=1]-Pr[output(PrivK^{eav}_{A,\Pi}(n,1))=1]| &lt;= negl(n)$"></a>等价公式：$|Pr[output(PrivK^{eav}_{A,\Pi}(n,0))=1]-Pr[output(PrivK^{eav}_{A,\Pi}(n,1))=1]| &lt;= negl(n)$</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码学（1）</title>
    <link href="/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89/"/>
    <url>/2019/12/09/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章 概论"></a>第一章 概论</h1><h2 id="1-2-对称密钥加密"><a href="#1-2-对称密钥加密" class="headerlink" title="1.2 对称密钥加密"></a>1.2 对称密钥加密</h2><p>对称密钥（秘密密钥）：双方共享密码信息（密钥）</p><ul><li>消息本身称为明文</li><li>加密后的消息称为密文</li></ul><p>对称密钥加密方案包含的三个算法：密钥产生、加密、解密</p><ul><li><strong>密钥产生算法（Gen）</strong>：概率算法，根据方案定义的某种分布选择并输出一个密钥<em>k</em></li><li><strong>加密算法（Enc）</strong>：输入密钥<em>k</em>和明文<em>m</em>，输出密文<em>c</em>。记为$Enc_k(m)$</li><li><strong>解密算法（Dec）</strong>：输入密钥<em>k</em>和密文<em>c</em>，输出明文<em>m</em>。记为$Dec_k(c)$</li><li><strong>密钥空间（<em>K</em>）</strong>：密钥产生函数输出的所有可能密钥称为密钥空间</li><li><strong>明文（消息）空间（<em>M</em>）</strong>：所有被加密算法支持的消息的集合</li><li>一个加密方案可由明确三个算法（Gen，Enc，Dec）和明文空间<em>M</em>来完全定义</li></ul><p><strong>攻击场景</strong></p><ul><li><p><strong>唯密文攻击</strong>：仅已知密文</p></li><li><p><strong>已知明文攻击</strong>：已知一个或多个使用相同密钥加密的明文/密文对</p></li><li><p><strong>选择明文攻击</strong>：可以选择明文得到其对应密文</p></li><li><p><strong>选择密文攻击</strong>：可以选择密文得到其对应明文</p></li></ul><h2 id="1-3-古典加密术及其密码分析"><a href="#1-3-古典加密术及其密码分析" class="headerlink" title="1.3 古典加密术及其密码分析"></a>1.3 古典加密术及其密码分析</h2><p><strong>凯撒加密</strong>：移位3字母</p><p><strong>移位加密</strong>:密钥<em>k</em>∈(0,25)，加密时字母移动<em>k</em>个位置</p><p><em>密钥空间充分性原则：任何安全的加密方案必须拥有一个能够抵御穷举搜索的密钥空间</em></p><p><strong>单字母替换（substitution）</strong>：一一映射</p><p><strong>多字母移位加密（Vigenere）</strong>：如图</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/1.png" srcset="/img/loading.gif" alt></p><h1 id="第二章-完善保密加密"><a href="#第二章-完善保密加密" class="headerlink" title="第二章 完善保密加密"></a>第二章 完善保密加密</h1><h2 id="2-1-完善保密加密"><a href="#2-1-完善保密加密" class="headerlink" title="2.1 完善保密加密"></a>2.1 完善保密加密</h2><p><strong>完善保密加密：</strong></p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302123938147.png" srcset="/img/loading.gif" alt="image-20200302123938147"></p><p><strong>完美不可区分性：</strong>密文不包含任何明文信息（密文空间的概率分布独立于明文？）</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135646380.png" srcset="/img/loading.gif" alt="image-20200302135646380"></p><p><strong>敌手不可区分性：</strong>敌手不能区分密文时来自哪个明文的加密</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135906974.png" srcset="/img/loading.gif" alt="image-20200302135906974"></p><p>其中：</p><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135937398.png" srcset="/img/loading.gif" alt="image-20200302135937398"></p><h2 id="2-2-一次一密（Vernam加密）"><a href="#2-2-一次一密（Vernam加密）" class="headerlink" title="2.2 一次一密（Vernam加密）"></a>2.2 一次一密（Vernam加密）</h2><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302135958699.png" srcset="/img/loading.gif" alt="image-20200302135958699"></p><h2 id="2-3-完善保密加密局限"><a href="#2-3-完善保密加密局限" class="headerlink" title="2.3 完善保密加密局限"></a>2.3 完善保密加密局限</h2><p><img src="/img/%E5%AF%86%E7%A0%81%E5%AD%A6%EF%BC%881%EF%BC%89.assets/image-20200302140015396.png" srcset="/img/loading.gif" alt="image-20200302140015396"></p><h2 id="2-4-香农定理"><a href="#2-4-香农定理" class="headerlink" title="2.4 香农定理"></a>2.4 香农定理</h2><p> 定理：设加密方案 （Gen,Enc,Dec）的明文空间为<em>M</em>，且|<em>K</em>|=|<em>M</em>|=|<em>C</em>|，则当且仅当下列条件成立时，此方案是完善保密加密：</p><ul><li>由Gen产生的任意密钥<em>k</em>∈<em>K</em>的概率都是1/|<em>K</em>|。</li><li>对任意明文<em>m</em>∈<em>M</em>和任意密文<em>c</em>∈<em>C</em>，只存在唯一的密钥<em>k</em>∈<em>K</em>使得$Enc_k(m)$输出<em>c</em>。</li></ul><script type="math/tex; mode=display">a+b=c</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络1</title>
    <link href="/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/"/>
    <url>/2019/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C1/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络-1"><a href="#计算机网络-1" class="headerlink" title="计算机网络 1"></a>计算机网络 1</h1><h2 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h2><p><strong>计算机网络的定义：</strong>计算机网络是<strong>互联</strong>的，<strong>自治</strong>的计算机集合</p><ul><li>自治：无主从关系</li><li>互联：互联互通</li><li>计算机网络是一种<strong>通信网络</strong></li></ul><p>主机通过<strong>交换网络</strong>互连</p><p><strong>ISP</strong>：因特网服务提供商</p><p><strong>网络协议（协议）</strong>：是为了进行网络中数据交换而建立的规则、标准或约定。它规定了通信实体之间所交换的消息的<strong>格式</strong>、<strong>意义</strong>、<strong>顺序</strong>以及针对收到信息或发生的事件所采取的动作。</p><ul><li>三要素：<ul><li>语法：<em>数据与控制信息的结构或格式；信号电平。</em></li><li>语义：<em>要放发出何种控制信息、完成何种动作、做出何种响应；差错控制。</em></li><li>时序：<em>事件顺序；速度匹配。</em></li></ul></li><li>协议规范了网络中所有信息的发送和接收过程</li></ul><p><strong>计算机网络结构</strong>：</p><ul><li>网络边缘<ul><li>主机（端系统）</li><li>客户/服务器（C/S）应用模型</li><li>对等（P2P）应用模型<ul><li><em>在对等者之间分配任务和工作负载的分布式应用架构</em></li><li><em>网络的参与者共享他们所拥有的一部分硬件资源、这些资源通过网络提供服务和内容，可被其他节点直接访问二无需经过中间实体。</em></li><li><em>既是Server，也是Client。</em></li></ul></li></ul></li><li>接入网络，物理介质:<br>- </li><li>网络核心（核心网络）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
